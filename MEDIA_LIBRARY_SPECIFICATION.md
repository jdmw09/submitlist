# Personal Media Library - Technical Specification

**Version**: 1.0.0
**Date**: November 21, 2025
**Status**: Draft
**Product**: TaskManager Media Library Extension

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Product Overview](#2-product-overview)
3. [Architecture](#3-architecture)
4. [Database Schema](#4-database-schema)
5. [Storage System](#5-storage-system)
6. [API Specification](#6-api-specification)
7. [Media Processing Pipeline](#7-media-processing-pipeline)
8. [Tagging System](#8-tagging-system)
9. [Search & Filtering](#9-search--filtering)
10. [Frontend Specification](#10-frontend-specification)
11. [Mobile Specification](#11-mobile-specification)
12. [Billing Integration](#12-billing-integration)
13. [Security](#13-security)
14. [Performance](#14-performance)
15. [Implementation Phases](#15-implementation-phases)
16. [File Structure](#16-file-structure)

---

## 1. Executive Summary

### 1.1 Purpose

Build a personal media library feature within TaskManager that allows users to store, organize, and retrieve photos and videos using a flexible tagging system.

### 1.2 Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Storage Provider | DigitalOcean Spaces | Same vendor as hosting, S3-compatible |
| Image Format | JPEG | Universal compatibility, good compression |
| Max Resolution | 1080p (1920×1080) | Balance quality vs storage |
| Database | PostgreSQL (existing) | Full-text search, proven reliability |
| Integration | Same app, new "Media" tab | Unified experience, shared auth |
| Pricing | Same tiers, separate charge | Clear value, independent products |
| **Privacy** | **Privacy-first** | No scanning, no AI, no third-party access, EXIF stripped |

### 1.3 Pricing Structure

Media Library is billed **separately** from TaskManager:

| Tier | Storage | Price | Retention |
|------|---------|-------|-----------|
| Free | 250 MB | $0 | 7 days |
| Paid | 5 GB | $20/year | 30 days |
| Premium | 100 GB | $99/year | Unlimited |

**Example**: User with TaskManager Paid ($20/yr) + Media Library Premium ($99/yr) = $119/year total.

---

## 2. Product Overview

### 2.1 Core Features

#### MVP (Phase 1)
- Photo upload (JPEG, PNG, HEIC, GIF)
- Video upload (MP4, MOV, M4V)
- Automatic compression to 1080p max
- Thumbnail generation
- Flexible tagging system (name, username, location, custom)
- Tag-based search and filtering
- Albums/collections
- Gallery view with grid layout
- Lightbox media viewer
- Storage usage tracking
- Separate billing subscription

#### Phase 2
- Bulk operations (tag, delete, download)
- Sharing via links (expiring, password-protected)
- Duplicate detection
- EXIF metadata extraction
- Date-based organization

#### Phase 3
- Smart albums (auto-generated by date, location, tags)
- Favorites system
- Trash/recovery (30-day)
- Export/download all

### 2.2 User Stories

```
As a user, I want to:
- Upload photos and videos from my device
- Tag media with names, usernames, or custom labels
- Search my library by tags
- Create albums to group related media
- View my media in a clean gallery interface
- See how much storage I'm using
- Upgrade my plan if I need more storage
```

### 2.3 Non-Goals (Out of Scope)

- Photo editing (crop, filters, etc.)
- Face recognition / AI tagging
- Social features (comments, likes)
- Public galleries
- Real-time collaboration
- End-to-end encryption

---

## 3. Architecture

### 3.1 System Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              CLIENTS                                     │
├─────────────────────┬─────────────────────┬─────────────────────────────┤
│     Web (React)     │   Mobile (RN/Expo)  │        Future Apps          │
└─────────┬───────────┴──────────┬──────────┴──────────────┬──────────────┘
          │                      │                         │
          ▼                      ▼                         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         NGINX (Reverse Proxy)                            │
│                    SSL Termination, Rate Limiting                        │
└─────────────────────────────────┬───────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      EXPRESS.JS BACKEND (Node.js)                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │    Auth      │  │   Tasks      │  │   Media      │  │   Billing    │ │
│  │  Controller  │  │  Controller  │  │  Controller  │  │  Controller  │ │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘ │
│                                            │                             │
│  ┌─────────────────────────────────────────┼───────────────────────────┐ │
│  │                      SERVICES LAYER     │                           │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──┴───────────┐              │ │
│  │  │   Billing    │  │    Email     │  │    Media     │              │ │
│  │  │   Service    │  │   Service    │  │   Service    │              │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │ │
│  │                                            │                        │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌─────┴────────┐              │ │
│  │  │   Storage    │  │  Thumbnail   │  │    Search    │              │ │
│  │  │   Service    │  │   Service    │  │   Service    │              │ │
│  │  └──────┬───────┘  └──────┬───────┘  └──────────────┘              │ │
│  └─────────┼─────────────────┼─────────────────────────────────────────┘ │
│            │                 │                                           │
└────────────┼─────────────────┼───────────────────────────────────────────┘
             │                 │
             ▼                 ▼
┌────────────────────┐  ┌─────────────────┐  ┌─────────────────────────────┐
│  DigitalOcean      │  │  Sharp/FFmpeg   │  │       PostgreSQL            │
│     Spaces         │  │  (Processing)   │  │       Database              │
│                    │  │                 │  │                             │
│  ┌──────────────┐  │  │  - Resize       │  │  - Users                    │
│  │  /originals  │  │  │  - Compress     │  │  - Media Items              │
│  │  /thumbnails │  │  │  - Thumbnails   │  │  - Tags                     │
│  │  /processed  │  │  │  - Format conv  │  │  - Albums                   │
│  └──────────────┘  │  │                 │  │  - Subscriptions            │
└────────────────────┘  └─────────────────┘  └─────────────────────────────┘
```

### 3.2 Data Flow: Upload

```
┌──────┐    ┌─────────┐    ┌──────────┐    ┌──────────┐    ┌─────────┐
│Client│───▶│ Multer  │───▶│ Validate │───▶│ Process  │───▶│  Store  │
└──────┘    │(Memory) │    │ & Check  │    │ (Sharp/  │    │  (DO    │
            │         │    │ Storage  │    │  FFmpeg) │    │ Spaces) │
            └─────────┘    └──────────┘    └──────────┘    └────┬────┘
                                                                │
                                ┌───────────────────────────────┘
                                ▼
                          ┌──────────┐    ┌──────────┐
                          │  Save    │───▶│ Return   │
                          │ Metadata │    │ Response │
                          │  (PG)    │    │          │
                          └──────────┘    └──────────┘
```

### 3.3 Component Responsibilities

| Component | Responsibility |
|-----------|----------------|
| **mediaController** | HTTP request handling, validation, response formatting |
| **mediaService** | Business logic, orchestration |
| **storageService** | DO Spaces upload/download/delete operations |
| **thumbnailService** | Generate thumbnails, resize images |
| **mediaSearchService** | PostgreSQL full-text search queries |
| **mediaBillingService** | Storage tracking, plan enforcement |

---

## 4. Database Schema

### 4.1 New Tables

```sql
-- ============================================
-- MEDIA LIBRARY SCHEMA
-- Migration: 006_media_library.sql
-- ============================================

-- ---------------------------------------------
-- Media Items (Core table)
-- ---------------------------------------------
CREATE TABLE media_items (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- File identification
    uuid VARCHAR(36) NOT NULL UNIQUE,  -- Public identifier (used in URLs)

    -- Original file info
    original_filename VARCHAR(255) NOT NULL,
    file_type VARCHAR(10) NOT NULL CHECK (file_type IN ('image', 'video')),
    mime_type VARCHAR(100) NOT NULL,
    original_size_bytes BIGINT NOT NULL,

    -- Processed file info
    processed_size_bytes BIGINT NOT NULL,
    width INTEGER,
    height INTEGER,
    duration_seconds INTEGER,  -- For videos only

    -- Storage keys (DO Spaces paths)
    storage_key VARCHAR(500) NOT NULL,      -- Processed file
    thumbnail_key VARCHAR(500),              -- Thumbnail (always JPEG)
    original_key VARCHAR(500),               -- Original (Premium only)

    -- Metadata
    title VARCHAR(255),
    description TEXT,
    taken_at TIMESTAMP,                      -- From EXIF or user-set

    -- Search optimization
    search_vector TSVECTOR,                  -- Full-text search

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE,    -- Soft delete

    -- Indexes
    CONSTRAINT valid_dimensions CHECK (
        (file_type = 'image' AND width IS NOT NULL AND height IS NOT NULL) OR
        (file_type = 'video')
    )
);

-- Indexes for media_items
CREATE INDEX idx_media_items_user_id ON media_items(user_id);
CREATE INDEX idx_media_items_uuid ON media_items(uuid);
CREATE INDEX idx_media_items_user_created ON media_items(user_id, created_at DESC);
CREATE INDEX idx_media_items_user_type ON media_items(user_id, file_type);
CREATE INDEX idx_media_items_search ON media_items USING GIN(search_vector);
CREATE INDEX idx_media_items_deleted ON media_items(deleted_at) WHERE deleted_at IS NOT NULL;

-- ---------------------------------------------
-- Tags (User-defined labels)
-- ---------------------------------------------
CREATE TABLE media_tags (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Tag definition
    tag_type VARCHAR(50) NOT NULL CHECK (tag_type IN ('name', 'username', 'location', 'event', 'custom')),
    tag_value VARCHAR(255) NOT NULL,

    -- Display
    color VARCHAR(7) DEFAULT '#6366f1',  -- Hex color for UI chips

    -- Usage tracking
    usage_count INTEGER DEFAULT 0,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- Unique per user
    UNIQUE(user_id, tag_type, tag_value)
);

CREATE INDEX idx_media_tags_user ON media_tags(user_id);
CREATE INDEX idx_media_tags_user_type ON media_tags(user_id, tag_type);
CREATE INDEX idx_media_tags_usage ON media_tags(user_id, usage_count DESC);

-- ---------------------------------------------
-- Media-Tag Junction (Many-to-Many)
-- ---------------------------------------------
CREATE TABLE media_item_tags (
    media_item_id INTEGER NOT NULL REFERENCES media_items(id) ON DELETE CASCADE,
    tag_id INTEGER NOT NULL REFERENCES media_tags(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    PRIMARY KEY (media_item_id, tag_id)
);

CREATE INDEX idx_media_item_tags_tag ON media_item_tags(tag_id);
CREATE INDEX idx_media_item_tags_item ON media_item_tags(media_item_id);

-- ---------------------------------------------
-- Albums (Collections)
-- ---------------------------------------------
CREATE TABLE media_albums (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Album info
    name VARCHAR(255) NOT NULL,
    description TEXT,

    -- Cover image
    cover_media_id INTEGER REFERENCES media_items(id) ON DELETE SET NULL,

    -- Stats (denormalized for performance)
    item_count INTEGER DEFAULT 0,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_media_albums_user ON media_albums(user_id);

-- ---------------------------------------------
-- Album-Media Junction (Many-to-Many)
-- ---------------------------------------------
CREATE TABLE media_album_items (
    album_id INTEGER NOT NULL REFERENCES media_albums(id) ON DELETE CASCADE,
    media_item_id INTEGER NOT NULL REFERENCES media_items(id) ON DELETE CASCADE,

    -- Ordering within album
    position INTEGER NOT NULL DEFAULT 0,

    -- Timestamps
    added_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    PRIMARY KEY (album_id, media_item_id)
);

CREATE INDEX idx_media_album_items_album ON media_album_items(album_id, position);
CREATE INDEX idx_media_album_items_media ON media_album_items(media_item_id);

-- ---------------------------------------------
-- Media User Storage (Separate from TaskManager)
-- ---------------------------------------------
CREATE TABLE media_user_storage (
    user_id INTEGER PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

    -- Storage tracking
    total_bytes BIGINT DEFAULT 0,
    file_count INTEGER DEFAULT 0,
    image_count INTEGER DEFAULT 0,
    video_count INTEGER DEFAULT 0,

    -- Timestamps
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ---------------------------------------------
-- Media Subscriptions (Separate from TaskManager)
-- ---------------------------------------------
CREATE TABLE media_subscriptions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Plan info
    plan_id INTEGER NOT NULL REFERENCES subscription_plans(id),

    -- Status
    status VARCHAR(20) NOT NULL DEFAULT 'active'
        CHECK (status IN ('active', 'canceled', 'past_due', 'expired')),

    -- Payment provider
    provider VARCHAR(20) CHECK (provider IN ('stripe', 'apple', 'google')),
    provider_subscription_id VARCHAR(255),

    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- One active subscription per user
    UNIQUE(user_id)
);

CREATE INDEX idx_media_subscriptions_user ON media_subscriptions(user_id);
CREATE INDEX idx_media_subscriptions_status ON media_subscriptions(status);

-- ---------------------------------------------
-- Media Subscription Receipts
-- ---------------------------------------------
CREATE TABLE media_subscription_receipts (
    id SERIAL PRIMARY KEY,
    subscription_id INTEGER NOT NULL REFERENCES media_subscriptions(id) ON DELETE CASCADE,

    -- Receipt info
    provider VARCHAR(20) NOT NULL,
    provider_receipt_id VARCHAR(255),
    amount_cents INTEGER NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ---------------------------------------------
-- Trigger: Update search vector on insert/update
-- ---------------------------------------------
CREATE OR REPLACE FUNCTION update_media_search_vector()
RETURNS TRIGGER AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
        setweight(to_tsvector('english', COALESCE(NEW.original_filename, '')), 'C');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER media_items_search_update
    BEFORE INSERT OR UPDATE OF title, description, original_filename
    ON media_items
    FOR EACH ROW
    EXECUTE FUNCTION update_media_search_vector();

-- ---------------------------------------------
-- Trigger: Update album item count
-- ---------------------------------------------
CREATE OR REPLACE FUNCTION update_album_item_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE media_albums SET item_count = item_count + 1, updated_at = NOW()
        WHERE id = NEW.album_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE media_albums SET item_count = item_count - 1, updated_at = NOW()
        WHERE id = OLD.album_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER album_items_count_trigger
    AFTER INSERT OR DELETE ON media_album_items
    FOR EACH ROW
    EXECUTE FUNCTION update_album_item_count();

-- ---------------------------------------------
-- Trigger: Update tag usage count
-- ---------------------------------------------
CREATE OR REPLACE FUNCTION update_tag_usage_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE media_tags SET usage_count = usage_count + 1
        WHERE id = NEW.tag_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE media_tags SET usage_count = usage_count - 1
        WHERE id = OLD.tag_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER item_tags_usage_trigger
    AFTER INSERT OR DELETE ON media_item_tags
    FOR EACH ROW
    EXECUTE FUNCTION update_tag_usage_count();

-- ---------------------------------------------
-- Function: Get user's effective media plan
-- ---------------------------------------------
CREATE OR REPLACE FUNCTION get_media_plan_limits(p_user_id INTEGER)
RETURNS TABLE (
    storage_limit_bytes BIGINT,
    retention_days INTEGER,
    plan_name VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        sp.storage_limit_bytes,
        sp.retention_days,
        sp.name
    FROM media_subscriptions ms
    JOIN subscription_plans sp ON ms.plan_id = sp.id
    WHERE ms.user_id = p_user_id AND ms.status = 'active';

    -- If no subscription, return free tier
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT
            sp.storage_limit_bytes,
            sp.retention_days,
            sp.name
        FROM subscription_plans sp
        WHERE sp.name = 'free';
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 Entity Relationship Diagram

```
┌─────────────────┐
│     users       │
│─────────────────│
│ id (PK)         │
│ email           │
│ username        │
└────────┬────────┘
         │
         │ 1:N
         ▼
┌─────────────────────────────────────────────────────────────────────┐
│                                                                      │
│  ┌─────────────────┐      ┌─────────────────┐      ┌──────────────┐ │
│  │  media_items    │      │   media_tags    │      │ media_albums │ │
│  │─────────────────│      │─────────────────│      │──────────────│ │
│  │ id (PK)         │      │ id (PK)         │      │ id (PK)      │ │
│  │ user_id (FK)    │      │ user_id (FK)    │      │ user_id (FK) │ │
│  │ uuid            │      │ tag_type        │      │ name         │ │
│  │ file_type       │      │ tag_value       │      │ description  │ │
│  │ storage_key     │      │ color           │      │ cover_media  │ │
│  │ thumbnail_key   │      │ usage_count     │      │ item_count   │ │
│  │ ...             │      └────────┬────────┘      └──────┬───────┘ │
│  └────────┬────────┘               │                      │         │
│           │                        │                      │         │
│           │         ┌──────────────┴──────────────┐       │         │
│           │         │    media_item_tags          │       │         │
│           │         │    (Junction Table)         │       │         │
│           └────────▶│ media_item_id (FK)          │       │         │
│                     │ tag_id (FK)                 │       │         │
│                     └─────────────────────────────┘       │         │
│                                                           │         │
│           ┌───────────────────────────────────────────────┘         │
│           │         ┌─────────────────────────────┐                 │
│           │         │    media_album_items        │                 │
│           │         │    (Junction Table)         │                 │
│           └────────▶│ album_id (FK)               │                 │
│                     │ media_item_id (FK)          │                 │
│                     │ position                    │                 │
│                     └─────────────────────────────┘                 │
│                                                                      │
│  ┌─────────────────────┐      ┌─────────────────────────────────┐   │
│  │ media_user_storage  │      │     media_subscriptions         │   │
│  │─────────────────────│      │─────────────────────────────────│   │
│  │ user_id (PK, FK)    │      │ id (PK)                         │   │
│  │ total_bytes         │      │ user_id (FK)                    │   │
│  │ file_count          │      │ plan_id (FK → subscription_plans)│   │
│  │ image_count         │      │ status                          │   │
│  │ video_count         │      │ provider                        │   │
│  └─────────────────────┘      └─────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. Storage System

### 5.1 DigitalOcean Spaces Configuration

```typescript
// Environment variables
DO_SPACES_ENDPOINT=nyc3.digitaloceanspaces.com
DO_SPACES_REGION=nyc3
DO_SPACES_BUCKET=taskmanager-media
DO_SPACES_ACCESS_KEY=<access_key>
DO_SPACES_SECRET_KEY=<secret_key>
DO_SPACES_CDN_ENDPOINT=taskmanager-media.nyc3.cdn.digitaloceanspaces.com
```

### 5.2 Storage Key Structure

```
taskmanager-media/                          # Bucket
├── users/
│   └── {user_id}/
│       ├── originals/                      # Original uploads (Premium only)
│       │   └── {year}/
│       │       └── {month}/
│       │           └── {uuid}.{ext}
│       ├── processed/                      # Resized to 1080p max
│       │   └── {year}/
│       │       └── {month}/
│       │           └── {uuid}.jpg          # Always JPEG
│       └── thumbnails/                     # 300px thumbnails
│           └── {uuid}_thumb.jpg
```

**Example paths:**
```
users/42/processed/2025/11/a1b2c3d4-5678-90ab-cdef.jpg
users/42/thumbnails/a1b2c3d4-5678-90ab-cdef_thumb.jpg
users/42/originals/2025/11/a1b2c3d4-5678-90ab-cdef.heic  # Premium only
```

### 5.3 Storage Service Interface

```typescript
// src/services/storageService.ts

interface StorageService {
  // Upload
  uploadFile(params: UploadParams): Promise<UploadResult>;
  uploadThumbnail(params: ThumbnailParams): Promise<string>;

  // Retrieve
  getSignedUrl(key: string, expiresIn?: number): Promise<string>;
  getPublicUrl(key: string): string;

  // Delete
  deleteFile(key: string): Promise<void>;
  deleteFiles(keys: string[]): Promise<void>;

  // Utilities
  fileExists(key: string): Promise<boolean>;
  getFileSize(key: string): Promise<number>;
}

interface UploadParams {
  buffer: Buffer;
  key: string;
  contentType: string;
  metadata?: Record<string, string>;
}

interface UploadResult {
  key: string;
  url: string;
  size: number;
}
```

### 5.4 CDN Configuration

DigitalOcean Spaces includes built-in CDN:

```
Origin:  https://taskmanager-media.nyc3.digitaloceanspaces.com
CDN:     https://taskmanager-media.nyc3.cdn.digitaloceanspaces.com
```

**Usage in responses:**
```typescript
// Return CDN URLs for processed images and thumbnails
const cdnUrl = `https://${DO_SPACES_CDN_ENDPOINT}/${storageKey}`;
```

### 5.5 Access Control

```typescript
// Bucket policy: Private by default
// All access through signed URLs or CDN with token

// For thumbnails: Public via CDN (fast loading)
// For full images: Signed URLs (7-day expiry)
// For videos: Signed URLs (7-day expiry)
```

---

## 6. API Specification

### 6.1 Base URL

```
Production: https://submitlist.space/api/media
Development: http://localhost:3000/api/media
```

### 6.2 Authentication

All endpoints require JWT authentication via `Authorization: Bearer <token>` header.

### 6.3 Endpoints Overview

| Method | Endpoint | Description |
|--------|----------|-------------|
| **Media Items** |
| POST | `/upload` | Upload media file |
| GET | `/items` | List user's media |
| GET | `/items/:uuid` | Get single media item |
| PATCH | `/items/:uuid` | Update media metadata |
| DELETE | `/items/:uuid` | Delete media item |
| POST | `/items/:uuid/tags` | Add tags to media |
| DELETE | `/items/:uuid/tags/:tagId` | Remove tag from media |
| **Tags** |
| GET | `/tags` | List user's tags |
| POST | `/tags` | Create new tag |
| PATCH | `/tags/:id` | Update tag |
| DELETE | `/tags/:id` | Delete tag |
| GET | `/tags/suggestions` | Get tag suggestions |
| **Albums** |
| GET | `/albums` | List user's albums |
| POST | `/albums` | Create album |
| GET | `/albums/:id` | Get album with items |
| PATCH | `/albums/:id` | Update album |
| DELETE | `/albums/:id` | Delete album |
| POST | `/albums/:id/items` | Add items to album |
| DELETE | `/albums/:id/items/:mediaId` | Remove item from album |
| PATCH | `/albums/:id/reorder` | Reorder album items |
| **Search** |
| GET | `/search` | Search media by tags/text |
| **Storage & Billing** |
| GET | `/storage` | Get storage usage |
| GET | `/subscription` | Get subscription status |
| POST | `/subscription/checkout` | Create Stripe checkout |
| POST | `/subscription/cancel` | Cancel subscription |

### 6.4 Detailed Endpoint Specifications

#### 6.4.1 Upload Media

```http
POST /api/media/upload
Content-Type: multipart/form-data
Authorization: Bearer <token>
```

**Request:**
```
file: <binary>              # Required - Image or video file
title: string               # Optional - Display title
description: string         # Optional - Description
tags: string[]              # Optional - Tag IDs to attach
taken_at: ISO8601           # Optional - Override capture date
```

**Validation:**
- Max file size: 100MB (images), 500MB (videos)
- Allowed image types: `image/jpeg`, `image/png`, `image/gif`, `image/heic`, `image/webp`
- Allowed video types: `video/mp4`, `video/quicktime`, `video/x-m4v`
- Storage quota enforced

**Response (201 Created):**
```json
{
  "success": true,
  "data": {
    "uuid": "a1b2c3d4-5678-90ab-cdef",
    "file_type": "image",
    "mime_type": "image/jpeg",
    "original_filename": "vacation.jpg",
    "width": 1920,
    "height": 1080,
    "processed_size_bytes": 245678,
    "thumbnail_url": "https://cdn.../thumbnails/a1b2c3d4_thumb.jpg",
    "url": "https://cdn.../processed/2025/11/a1b2c3d4.jpg",
    "title": null,
    "description": null,
    "tags": [],
    "taken_at": "2025-11-15T10:30:00Z",
    "created_at": "2025-11-21T14:30:00Z"
  }
}
```

**Error Responses:**
```json
// 400 Bad Request - Invalid file type
{
  "success": false,
  "error": "Invalid file type. Allowed: JPEG, PNG, GIF, HEIC, WebP, MP4, MOV"
}

// 413 Payload Too Large - File too big
{
  "success": false,
  "error": "File size exceeds limit (100MB for images, 500MB for videos)"
}

// 402 Payment Required - Storage exceeded
{
  "success": false,
  "error": "Storage limit exceeded",
  "storage": {
    "used_bytes": 262144000,
    "limit_bytes": 262144000,
    "plan": "free"
  }
}
```

#### 6.4.2 List Media Items

```http
GET /api/media/items
Authorization: Bearer <token>
```

**Query Parameters:**
| Param | Type | Default | Description |
|-------|------|---------|-------------|
| `page` | number | 1 | Page number |
| `limit` | number | 50 | Items per page (max 100) |
| `type` | string | all | Filter: `image`, `video`, `all` |
| `tags` | string | - | Comma-separated tag IDs |
| `album_id` | number | - | Filter by album |
| `sort` | string | `created_desc` | Sort order |
| `from_date` | ISO8601 | - | Filter from date |
| `to_date` | ISO8601 | - | Filter to date |

**Sort options:**
- `created_desc` (default) - Newest first
- `created_asc` - Oldest first
- `taken_desc` - By capture date, newest
- `taken_asc` - By capture date, oldest
- `name_asc` - Alphabetical by filename
- `size_desc` - Largest first

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "uuid": "a1b2c3d4-5678-90ab-cdef",
        "file_type": "image",
        "original_filename": "vacation.jpg",
        "width": 1920,
        "height": 1080,
        "thumbnail_url": "https://cdn.../a1b2c3d4_thumb.jpg",
        "title": "Beach Sunset",
        "tags": [
          { "id": 1, "type": "location", "value": "Hawaii", "color": "#10b981" },
          { "id": 5, "type": "name", "value": "John", "color": "#6366f1" }
        ],
        "taken_at": "2025-11-15T10:30:00Z",
        "created_at": "2025-11-21T14:30:00Z"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 50,
      "total_items": 342,
      "total_pages": 7
    }
  }
}
```

#### 6.4.3 Get Single Media Item

```http
GET /api/media/items/:uuid
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "uuid": "a1b2c3d4-5678-90ab-cdef",
    "file_type": "image",
    "mime_type": "image/jpeg",
    "original_filename": "vacation.jpg",
    "width": 1920,
    "height": 1080,
    "processed_size_bytes": 245678,
    "original_size_bytes": 4567890,
    "thumbnail_url": "https://cdn.../a1b2c3d4_thumb.jpg",
    "url": "https://signed-url...",
    "original_url": null,  // Only for Premium users
    "title": "Beach Sunset",
    "description": "Beautiful sunset at Waikiki Beach",
    "tags": [
      { "id": 1, "type": "location", "value": "Hawaii", "color": "#10b981" },
      { "id": 5, "type": "name", "value": "John", "color": "#6366f1" }
    ],
    "albums": [
      { "id": 3, "name": "Vacation 2025" }
    ],
    "taken_at": "2025-11-15T10:30:00Z",
    "created_at": "2025-11-21T14:30:00Z",
    "updated_at": "2025-11-21T14:30:00Z"
  }
}
```

#### 6.4.4 Update Media Item

```http
PATCH /api/media/items/:uuid
Authorization: Bearer <token>
Content-Type: application/json
```

**Request:**
```json
{
  "title": "Updated Title",
  "description": "Updated description",
  "taken_at": "2025-11-15T10:30:00Z"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "uuid": "a1b2c3d4-5678-90ab-cdef",
    "title": "Updated Title",
    "description": "Updated description",
    "taken_at": "2025-11-15T10:30:00Z",
    "updated_at": "2025-11-21T15:00:00Z"
  }
}
```

#### 6.4.5 Delete Media Item

```http
DELETE /api/media/items/:uuid
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Media item deleted",
  "storage": {
    "freed_bytes": 245678,
    "used_bytes": 150000000,
    "limit_bytes": 262144000
  }
}
```

#### 6.4.6 Add Tags to Media

```http
POST /api/media/items/:uuid/tags
Authorization: Bearer <token>
Content-Type: application/json
```

**Request:**
```json
{
  "tags": [
    { "id": 1 },                              // Existing tag by ID
    { "type": "name", "value": "Sarah" },     // Create new tag
    { "type": "custom", "value": "Birthday" }
  ]
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "tags": [
      { "id": 1, "type": "location", "value": "Hawaii", "color": "#10b981" },
      { "id": 12, "type": "name", "value": "Sarah", "color": "#6366f1" },
      { "id": 13, "type": "custom", "value": "Birthday", "color": "#6366f1" }
    ]
  }
}
```

#### 6.4.7 List Tags

```http
GET /api/media/tags
Authorization: Bearer <token>
```

**Query Parameters:**
| Param | Type | Default | Description |
|-------|------|---------|-------------|
| `type` | string | - | Filter by tag type |
| `sort` | string | `usage_desc` | Sort order |

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "tags": [
      { "id": 1, "type": "name", "value": "John", "color": "#6366f1", "usage_count": 45 },
      { "id": 2, "type": "name", "value": "Sarah", "color": "#ec4899", "usage_count": 32 },
      { "id": 3, "type": "location", "value": "New York", "color": "#10b981", "usage_count": 28 },
      { "id": 4, "type": "username", "value": "@johndoe", "color": "#f59e0b", "usage_count": 15 }
    ],
    "summary": {
      "total": 24,
      "by_type": {
        "name": 8,
        "username": 5,
        "location": 6,
        "event": 2,
        "custom": 3
      }
    }
  }
}
```

#### 6.4.8 Create Tag

```http
POST /api/media/tags
Authorization: Bearer <token>
Content-Type: application/json
```

**Request:**
```json
{
  "type": "name",
  "value": "Emily",
  "color": "#8b5cf6"
}
```

**Response (201 Created):**
```json
{
  "success": true,
  "data": {
    "id": 25,
    "type": "name",
    "value": "Emily",
    "color": "#8b5cf6",
    "usage_count": 0,
    "created_at": "2025-11-21T15:30:00Z"
  }
}
```

#### 6.4.9 Tag Suggestions

```http
GET /api/media/tags/suggestions?q=jo
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "suggestions": [
      { "id": 1, "type": "name", "value": "John", "usage_count": 45 },
      { "id": 15, "type": "name", "value": "Jordan", "usage_count": 12 },
      { "id": 22, "type": "username", "value": "@johnsmith", "usage_count": 8 }
    ]
  }
}
```

#### 6.4.10 Search Media

```http
GET /api/media/search?q=beach hawaii john
Authorization: Bearer <token>
```

**Query Parameters:**
| Param | Type | Description |
|-------|------|-------------|
| `q` | string | Search query (searches tags, title, filename) |
| `tags` | string | Comma-separated tag IDs (AND filter) |
| `type` | string | `image`, `video`, or `all` |
| `from_date` | ISO8601 | Filter from date |
| `to_date` | ISO8601 | Filter to date |
| `page` | number | Page number |
| `limit` | number | Items per page |

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "items": [...],
    "query": "beach hawaii john",
    "matched_tags": [
      { "id": 1, "type": "location", "value": "Hawaii" },
      { "id": 5, "type": "name", "value": "John" }
    ],
    "pagination": {
      "page": 1,
      "limit": 50,
      "total_items": 23,
      "total_pages": 1
    }
  }
}
```

#### 6.4.11 Create Album

```http
POST /api/media/albums
Authorization: Bearer <token>
Content-Type: application/json
```

**Request:**
```json
{
  "name": "Summer Vacation 2025",
  "description": "Trip to Hawaii",
  "cover_media_uuid": "a1b2c3d4-5678-90ab-cdef",
  "item_uuids": ["uuid1", "uuid2", "uuid3"]
}
```

**Response (201 Created):**
```json
{
  "success": true,
  "data": {
    "id": 5,
    "name": "Summer Vacation 2025",
    "description": "Trip to Hawaii",
    "cover_url": "https://cdn.../a1b2c3d4_thumb.jpg",
    "item_count": 3,
    "created_at": "2025-11-21T16:00:00Z"
  }
}
```

#### 6.4.12 Get Storage Status

```http
GET /api/media/storage
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "used_bytes": 150000000,
    "limit_bytes": 262144000,
    "used_percentage": 57.2,
    "file_count": 234,
    "image_count": 210,
    "video_count": 24,
    "plan": {
      "name": "free",
      "storage_limit_bytes": 262144000,
      "retention_days": 7
    },
    "retention_warning": {
      "files_expiring_soon": 12,
      "expires_at": "2025-11-28T00:00:00Z"
    }
  }
}
```

#### 6.4.13 Get Subscription Status

```http
GET /api/media/subscription
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "has_subscription": true,
    "plan": {
      "id": 2,
      "name": "paid",
      "display_name": "Media Library Paid",
      "price_cents": 2000,
      "price_display": "$20/year",
      "storage_limit_bytes": 5368709120,
      "storage_limit_display": "5 GB",
      "retention_days": 30
    },
    "status": "active",
    "provider": "stripe",
    "current_period_end": "2026-11-21T00:00:00Z",
    "cancel_at_period_end": false
  }
}
```

#### 6.4.14 Create Checkout Session

```http
POST /api/media/subscription/checkout
Authorization: Bearer <token>
Content-Type: application/json
```

**Request:**
```json
{
  "plan": "paid",
  "success_url": "https://submitlist.space/media/settings?success=true",
  "cancel_url": "https://submitlist.space/media/settings?canceled=true"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "checkout_url": "https://checkout.stripe.com/c/pay/cs_live_..."
  }
}
```

---

## 7. Media Processing Pipeline

### 7.1 Image Processing

```typescript
// src/services/thumbnailService.ts

interface ImageProcessingConfig {
  // Processed image (main display)
  processed: {
    maxWidth: 1920,
    maxHeight: 1080,
    quality: 85,
    format: 'jpeg'
  },
  // Thumbnail (gallery grid)
  thumbnail: {
    width: 300,
    height: 300,
    fit: 'cover',
    quality: 80,
    format: 'jpeg'
  }
}
```

**Processing Steps:**

```
Input File
    │
    ▼
┌─────────────────────────────────────┐
│  1. VALIDATE                        │
│  - Check file type                  │
│  - Check file size                  │
│  - Extract EXIF metadata            │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  2. CONVERT (if needed)             │
│  - HEIC → JPEG                      │
│  - PNG → JPEG (if no transparency)  │
│  - WebP → JPEG                      │
│  - GIF → keep as GIF (animated)     │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  3. RESIZE (Processed)              │
│  - Max 1920×1080                    │
│  - Maintain aspect ratio            │
│  - Sharp: resize({ width, height,   │
│           fit: 'inside' })          │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  4. COMPRESS                        │
│  - JPEG quality: 85%                │
│  - mozjpeg compression              │
│  - Strip metadata (except rotation) │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  5. GENERATE THUMBNAIL              │
│  - 300×300 square crop              │
│  - Smart crop (attention-based)     │
│  - JPEG quality: 80%                │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  6. UPLOAD TO DO SPACES             │
│  - Processed → /processed/          │
│  - Thumbnail → /thumbnails/         │
│  - Original → /originals/ (Premium) │
└─────────────────────────────────────┘
```

### 7.2 Video Processing

```typescript
// Video processing config
interface VideoProcessingConfig {
  processed: {
    maxWidth: 1920,
    maxHeight: 1080,
    codec: 'libx264',
    preset: 'medium',
    crf: 23,           // Quality (18-28, lower = better)
    audioCodec: 'aac',
    audioBitrate: '128k',
    format: 'mp4'
  },
  thumbnail: {
    width: 300,
    height: 300,
    format: 'jpeg',
    timestamp: '00:00:01'  // Extract at 1 second
  }
}
```

**Processing Steps:**

```
Input Video
    │
    ▼
┌─────────────────────────────────────┐
│  1. VALIDATE                        │
│  - Check file type                  │
│  - Check file size (max 500MB)      │
│  - Get video metadata (ffprobe)     │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  2. EXTRACT THUMBNAIL               │
│  - Frame at 1 second (or 25%)       │
│  - Resize to 300×300                │
│  - Save as JPEG                     │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  3. TRANSCODE (if needed)           │
│  - Input: MOV, M4V, etc.            │
│  - Output: MP4 (H.264)              │
│  - Max 1080p                        │
│  - CRF 23 (good quality/size)       │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│  4. UPLOAD TO DO SPACES             │
│  - Processed → /processed/          │
│  - Thumbnail → /thumbnails/         │
└─────────────────────────────────────┘
```

### 7.3 Sharp Implementation

```typescript
// src/utils/mediaProcessor.ts

import sharp from 'sharp';

export async function processImage(
  inputBuffer: Buffer,
  originalFilename: string
): Promise<ProcessedImage> {
  const metadata = await sharp(inputBuffer).metadata();

  // Determine if resize needed
  const needsResize =
    (metadata.width && metadata.width > 1920) ||
    (metadata.height && metadata.height > 1080);

  // Process main image
  let processor = sharp(inputBuffer)
    .rotate() // Auto-rotate based on EXIF
    .jpeg({ quality: 85, mozjpeg: true });

  if (needsResize) {
    processor = processor.resize(1920, 1080, {
      fit: 'inside',
      withoutEnlargement: true
    });
  }

  const processedBuffer = await processor.toBuffer();
  const processedMeta = await sharp(processedBuffer).metadata();

  // Generate thumbnail
  const thumbnailBuffer = await sharp(inputBuffer)
    .rotate()
    .resize(300, 300, {
      fit: 'cover',
      position: sharp.strategy.attention // Smart crop
    })
    .jpeg({ quality: 80 })
    .toBuffer();

  return {
    processed: {
      buffer: processedBuffer,
      width: processedMeta.width!,
      height: processedMeta.height!,
      size: processedBuffer.length
    },
    thumbnail: {
      buffer: thumbnailBuffer,
      size: thumbnailBuffer.length
    },
    original: {
      width: metadata.width!,
      height: metadata.height!,
      size: inputBuffer.length
    }
  };
}
```

### 7.4 FFmpeg Implementation

```typescript
// src/utils/videoProcessor.ts

import ffmpeg from 'fluent-ffmpeg';
import { path as ffmpegPath } from '@ffmpeg-installer/ffmpeg';

ffmpeg.setFfmpegPath(ffmpegPath);

export async function processVideo(
  inputPath: string,
  outputPath: string
): Promise<VideoMetadata> {
  return new Promise((resolve, reject) => {
    ffmpeg(inputPath)
      .outputOptions([
        '-c:v libx264',
        '-preset medium',
        '-crf 23',
        '-c:a aac',
        '-b:a 128k',
        '-movflags +faststart',  // Web optimization
        '-vf scale=\'min(1920,iw)\':\'min(1080,ih)\':force_original_aspect_ratio=decrease'
      ])
      .output(outputPath)
      .on('end', () => resolve(getVideoMetadata(outputPath)))
      .on('error', reject)
      .run();
  });
}

export async function extractVideoThumbnail(
  inputPath: string,
  outputPath: string,
  timestamp: string = '00:00:01'
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    ffmpeg(inputPath)
      .screenshots({
        timestamps: [timestamp],
        filename: 'thumb.jpg',
        folder: path.dirname(outputPath),
        size: '300x300'
      })
      .on('end', async () => {
        const buffer = await fs.readFile(outputPath);
        resolve(buffer);
      })
      .on('error', reject);
  });
}
```

---

## 8. Tagging System

### 8.1 Tag Types

| Type | Purpose | Example | Color (default) |
|------|---------|---------|-----------------|
| `name` | Person's name | "John Smith" | `#6366f1` (indigo) |
| `username` | Social handle | "@johndoe" | `#f59e0b` (amber) |
| `location` | Place | "New York" | `#10b981` (emerald) |
| `event` | Occasion | "Birthday 2025" | `#ec4899` (pink) |
| `custom` | User-defined | "Work" | `#8b5cf6` (violet) |

### 8.2 Tag Constraints

- **Tag value**: 1-255 characters
- **Tags per item**: No limit
- **Tags per user**: No limit
- **Unique constraint**: One tag per (user_id, type, value)
- **Case handling**: Case-insensitive matching, original case preserved

### 8.3 Tag Operations

```typescript
// Tag service interface
interface TagService {
  // CRUD
  createTag(userId: number, type: TagType, value: string, color?: string): Promise<Tag>;
  updateTag(tagId: number, updates: Partial<Tag>): Promise<Tag>;
  deleteTag(tagId: number): Promise<void>;

  // Retrieval
  getUserTags(userId: number, type?: TagType): Promise<Tag[]>;
  getTagById(tagId: number): Promise<Tag | null>;

  // Search
  searchTags(userId: number, query: string): Promise<Tag[]>;
  getSuggestions(userId: number, prefix: string): Promise<Tag[]>;

  // Media associations
  addTagsToMedia(mediaId: number, tagIds: number[]): Promise<void>;
  removeTagFromMedia(mediaId: number, tagId: number): Promise<void>;
  getMediaTags(mediaId: number): Promise<Tag[]>;

  // Bulk operations
  bulkTagMedia(mediaIds: number[], tagIds: number[]): Promise<void>;
}
```

### 8.4 Tag Search Algorithm

```sql
-- Suggestion query (prefix match + fuzzy)
SELECT id, tag_type, tag_value, color, usage_count
FROM media_tags
WHERE user_id = $1
  AND (
    -- Prefix match (highest priority)
    tag_value ILIKE $2 || '%'
    OR
    -- Contains match
    tag_value ILIKE '%' || $2 || '%'
  )
ORDER BY
  -- Prioritize exact prefix matches
  CASE WHEN tag_value ILIKE $2 || '%' THEN 0 ELSE 1 END,
  -- Then by usage
  usage_count DESC
LIMIT 10;
```

---

## 9. Search & Filtering

### 9.1 PostgreSQL Full-Text Search

```sql
-- Search query combining full-text and tag filtering
WITH tag_matches AS (
  -- Find tags matching search terms
  SELECT DISTINCT mit.media_item_id
  FROM media_tags mt
  JOIN media_item_tags mit ON mt.id = mit.tag_id
  WHERE mt.user_id = $1
    AND mt.tag_value ILIKE ANY($2)  -- Array of search terms
),
text_matches AS (
  -- Full-text search on title, description, filename
  SELECT id AS media_item_id,
         ts_rank(search_vector, plainto_tsquery('english', $3)) AS rank
  FROM media_items
  WHERE user_id = $1
    AND deleted_at IS NULL
    AND search_vector @@ plainto_tsquery('english', $3)
)
SELECT DISTINCT mi.*,
       COALESCE(tm.rank, 0) AS text_rank,
       CASE WHEN tag.media_item_id IS NOT NULL THEN 1 ELSE 0 END AS tag_match
FROM media_items mi
LEFT JOIN text_matches tm ON mi.id = tm.media_item_id
LEFT JOIN tag_matches tag ON mi.id = tag.media_item_id
WHERE mi.user_id = $1
  AND mi.deleted_at IS NULL
  AND (tm.media_item_id IS NOT NULL OR tag.media_item_id IS NOT NULL)
ORDER BY
  tag_match DESC,       -- Prioritize tag matches
  text_rank DESC,       -- Then text relevance
  mi.created_at DESC    -- Then recency
LIMIT $4 OFFSET $5;
```

### 9.2 Filter Combinations

```typescript
interface MediaFilters {
  // Text search
  query?: string;

  // Tag filters (AND logic)
  tagIds?: number[];
  tagTypes?: TagType[];

  // Type filter
  fileType?: 'image' | 'video' | 'all';

  // Date filters
  fromDate?: Date;
  toDate?: Date;

  // Album filter
  albumId?: number;

  // Sorting
  sortBy: 'created' | 'taken' | 'name' | 'size';
  sortOrder: 'asc' | 'desc';

  // Pagination
  page: number;
  limit: number;
}
```

### 9.3 Search Implementation

```typescript
// src/services/mediaSearchService.ts

export class MediaSearchService {
  async search(userId: number, filters: MediaFilters): Promise<SearchResult> {
    const conditions: string[] = ['mi.user_id = $1', 'mi.deleted_at IS NULL'];
    const params: any[] = [userId];
    let paramIndex = 2;

    // Full-text search
    if (filters.query) {
      const searchTerms = filters.query.split(/\s+/).filter(t => t.length > 0);

      // Search in tags
      conditions.push(`(
        mi.id IN (
          SELECT mit.media_item_id
          FROM media_item_tags mit
          JOIN media_tags mt ON mit.tag_id = mt.id
          WHERE mt.user_id = $1
            AND mt.tag_value ILIKE ANY($${paramIndex})
        )
        OR mi.search_vector @@ plainto_tsquery('english', $${paramIndex + 1})
      )`);
      params.push(searchTerms.map(t => `%${t}%`));
      params.push(filters.query);
      paramIndex += 2;
    }

    // Tag ID filter (AND logic - must have ALL specified tags)
    if (filters.tagIds?.length) {
      conditions.push(`(
        SELECT COUNT(DISTINCT mit.tag_id)
        FROM media_item_tags mit
        WHERE mit.media_item_id = mi.id
          AND mit.tag_id = ANY($${paramIndex})
      ) = $${paramIndex + 1}`);
      params.push(filters.tagIds);
      params.push(filters.tagIds.length);
      paramIndex += 2;
    }

    // File type filter
    if (filters.fileType && filters.fileType !== 'all') {
      conditions.push(`mi.file_type = $${paramIndex}`);
      params.push(filters.fileType);
      paramIndex++;
    }

    // Date range
    if (filters.fromDate) {
      conditions.push(`COALESCE(mi.taken_at, mi.created_at) >= $${paramIndex}`);
      params.push(filters.fromDate);
      paramIndex++;
    }
    if (filters.toDate) {
      conditions.push(`COALESCE(mi.taken_at, mi.created_at) <= $${paramIndex}`);
      params.push(filters.toDate);
      paramIndex++;
    }

    // Album filter
    if (filters.albumId) {
      conditions.push(`mi.id IN (
        SELECT media_item_id FROM media_album_items WHERE album_id = $${paramIndex}
      )`);
      params.push(filters.albumId);
      paramIndex++;
    }

    // Build ORDER BY
    const sortColumn = {
      created: 'mi.created_at',
      taken: 'COALESCE(mi.taken_at, mi.created_at)',
      name: 'mi.original_filename',
      size: 'mi.processed_size_bytes'
    }[filters.sortBy];
    const sortDir = filters.sortOrder.toUpperCase();

    // Count query
    const countQuery = `
      SELECT COUNT(*) as total
      FROM media_items mi
      WHERE ${conditions.join(' AND ')}
    `;

    // Main query
    const offset = (filters.page - 1) * filters.limit;
    const mainQuery = `
      SELECT
        mi.uuid, mi.file_type, mi.original_filename,
        mi.width, mi.height, mi.processed_size_bytes,
        mi.thumbnail_key, mi.title, mi.taken_at, mi.created_at,
        (
          SELECT json_agg(json_build_object(
            'id', mt.id, 'type', mt.tag_type,
            'value', mt.tag_value, 'color', mt.color
          ))
          FROM media_item_tags mit
          JOIN media_tags mt ON mit.tag_id = mt.id
          WHERE mit.media_item_id = mi.id
        ) as tags
      FROM media_items mi
      WHERE ${conditions.join(' AND ')}
      ORDER BY ${sortColumn} ${sortDir}
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    params.push(filters.limit, offset);

    const [countResult, itemsResult] = await Promise.all([
      pool.query(countQuery, params.slice(0, -2)),
      pool.query(mainQuery, params)
    ]);

    return {
      items: itemsResult.rows,
      pagination: {
        page: filters.page,
        limit: filters.limit,
        total_items: parseInt(countResult.rows[0].total),
        total_pages: Math.ceil(countResult.rows[0].total / filters.limit)
      }
    };
  }
}
```

---

## 10. Frontend Specification

### 10.1 Navigation Integration

```
TaskManager App (existing)
├── Tasks Tab (existing)
├── Organizations Tab (existing)
├── Media Tab (NEW) ◀─────────────
│   ├── Gallery View
│   ├── Albums
│   ├── Tags
│   └── Settings (storage/billing)
├── Notifications Tab (existing)
└── Profile Tab (existing)
```

### 10.2 New Pages

| Page | Route | Description |
|------|-------|-------------|
| MediaLibraryPage | `/media` | Main gallery grid |
| MediaViewerPage | `/media/:uuid` | Full-screen viewer |
| AlbumsPage | `/media/albums` | Album list |
| AlbumDetailPage | `/media/albums/:id` | Album contents |
| TagsPage | `/media/tags` | Tag management |
| MediaSettingsPage | `/media/settings` | Storage & billing |
| MediaUploadPage | `/media/upload` | Upload interface |

### 10.3 Component Hierarchy

```
MediaLibraryPage
├── MediaHeader
│   ├── SearchBar
│   ├── FilterDropdown (type, date range)
│   └── ViewToggle (grid/list)
├── TagFilter
│   └── TagChip[] (active filters)
├── MediaGrid
│   └── MediaCard[]
│       ├── Thumbnail
│       ├── SelectCheckbox
│       └── QuickActions (hover)
├── BulkActionBar (when items selected)
│   ├── AddTagsButton
│   ├── AddToAlbumButton
│   └── DeleteButton
├── UploadButton (FAB)
└── StorageIndicator
```

### 10.4 MediaGrid Component

```tsx
// web/src/components/media/MediaGrid.tsx

interface MediaGridProps {
  items: MediaItem[];
  loading: boolean;
  selectedIds: Set<string>;
  onSelect: (uuid: string, selected: boolean) => void;
  onItemClick: (uuid: string) => void;
  onLoadMore: () => void;
  hasMore: boolean;
}

const MediaGrid: React.FC<MediaGridProps> = ({
  items,
  loading,
  selectedIds,
  onSelect,
  onItemClick,
  onLoadMore,
  hasMore
}) => {
  return (
    <div className={styles.grid}>
      {items.map(item => (
        <MediaCard
          key={item.uuid}
          item={item}
          selected={selectedIds.has(item.uuid)}
          onSelect={(selected) => onSelect(item.uuid, selected)}
          onClick={() => onItemClick(item.uuid)}
        />
      ))}
      {loading && <LoadingSpinner />}
      {hasMore && !loading && (
        <IntersectionObserver onIntersect={onLoadMore} />
      )}
    </div>
  );
};
```

### 10.5 MediaCard Component

```tsx
// web/src/components/media/MediaCard.tsx

interface MediaCardProps {
  item: MediaItem;
  selected: boolean;
  onSelect: (selected: boolean) => void;
  onClick: () => void;
}

const MediaCard: React.FC<MediaCardProps> = ({
  item,
  selected,
  onSelect,
  onClick
}) => {
  const [isHovered, setIsHovered] = useState(false);

  return (
    <div
      className={cn(styles.card, { [styles.selected]: selected })}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={onClick}
    >
      {/* Thumbnail */}
      <div className={styles.thumbnail}>
        <img
          src={item.thumbnail_url}
          alt={item.title || item.original_filename}
          loading="lazy"
        />
        {item.file_type === 'video' && (
          <div className={styles.videoIndicator}>
            <PlayIcon />
            <span>{formatDuration(item.duration_seconds)}</span>
          </div>
        )}
      </div>

      {/* Selection checkbox */}
      <div
        className={cn(styles.checkbox, { [styles.visible]: isHovered || selected })}
        onClick={(e) => { e.stopPropagation(); onSelect(!selected); }}
      >
        <Checkbox checked={selected} />
      </div>

      {/* Tags preview */}
      {item.tags?.length > 0 && (
        <div className={styles.tags}>
          {item.tags.slice(0, 3).map(tag => (
            <span
              key={tag.id}
              className={styles.tag}
              style={{ backgroundColor: tag.color }}
            >
              {tag.value}
            </span>
          ))}
          {item.tags.length > 3 && (
            <span className={styles.moreTag}>+{item.tags.length - 3}</span>
          )}
        </div>
      )}
    </div>
  );
};
```

### 10.6 MediaViewer Component

```tsx
// web/src/components/media/MediaViewer.tsx

interface MediaViewerProps {
  item: MediaItemDetail;
  onClose: () => void;
  onPrevious: () => void;
  onNext: () => void;
  hasPrevious: boolean;
  hasNext: boolean;
}

const MediaViewer: React.FC<MediaViewerProps> = ({
  item,
  onClose,
  onPrevious,
  onNext,
  hasPrevious,
  hasNext
}) => {
  return (
    <div className={styles.overlay} onClick={onClose}>
      <div className={styles.viewer} onClick={(e) => e.stopPropagation()}>
        {/* Navigation */}
        <button
          className={styles.navButton}
          onClick={onPrevious}
          disabled={!hasPrevious}
        >
          <ChevronLeftIcon />
        </button>

        {/* Media display */}
        <div className={styles.mediaContainer}>
          {item.file_type === 'image' ? (
            <img src={item.url} alt={item.title} />
          ) : (
            <video src={item.url} controls autoPlay />
          )}
        </div>

        <button
          className={styles.navButton}
          onClick={onNext}
          disabled={!hasNext}
        >
          <ChevronRightIcon />
        </button>

        {/* Close button */}
        <button className={styles.closeButton} onClick={onClose}>
          <CloseIcon />
        </button>

        {/* Sidebar with details */}
        <div className={styles.sidebar}>
          <MediaDetails item={item} />
          <TagEditor itemId={item.uuid} tags={item.tags} />
          <AlbumSelector itemId={item.uuid} albums={item.albums} />
        </div>
      </div>
    </div>
  );
};
```

### 10.7 Upload Component

```tsx
// web/src/components/media/MediaUploader.tsx

interface MediaUploaderProps {
  onUploadComplete: () => void;
}

const MediaUploader: React.FC<MediaUploaderProps> = ({ onUploadComplete }) => {
  const [files, setFiles] = useState<UploadFile[]>([]);
  const [uploading, setUploading] = useState(false);

  const handleDrop = useCallback((acceptedFiles: File[]) => {
    const newFiles = acceptedFiles.map(file => ({
      id: crypto.randomUUID(),
      file,
      status: 'pending' as const,
      progress: 0
    }));
    setFiles(prev => [...prev, ...newFiles]);
  }, []);

  const uploadFile = async (uploadFile: UploadFile) => {
    const formData = new FormData();
    formData.append('file', uploadFile.file);

    try {
      await api.post('/media/upload', formData, {
        onUploadProgress: (progressEvent) => {
          const progress = Math.round(
            (progressEvent.loaded * 100) / progressEvent.total!
          );
          setFiles(prev => prev.map(f =>
            f.id === uploadFile.id ? { ...f, progress } : f
          ));
        }
      });

      setFiles(prev => prev.map(f =>
        f.id === uploadFile.id ? { ...f, status: 'complete' } : f
      ));
    } catch (error) {
      setFiles(prev => prev.map(f =>
        f.id === uploadFile.id ? { ...f, status: 'error', error: error.message } : f
      ));
    }
  };

  const handleUpload = async () => {
    setUploading(true);
    const pendingFiles = files.filter(f => f.status === 'pending');

    // Upload 3 at a time
    const chunks = chunk(pendingFiles, 3);
    for (const batch of chunks) {
      await Promise.all(batch.map(uploadFile));
    }

    setUploading(false);
    onUploadComplete();
  };

  return (
    <div className={styles.uploader}>
      <Dropzone onDrop={handleDrop} accept={ACCEPTED_TYPES}>
        {({ getRootProps, getInputProps, isDragActive }) => (
          <div
            {...getRootProps()}
            className={cn(styles.dropzone, { [styles.active]: isDragActive })}
          >
            <input {...getInputProps()} />
            <UploadIcon />
            <p>Drag photos & videos here, or click to select</p>
            <span>JPEG, PNG, GIF, HEIC, MP4, MOV (max 100MB images, 500MB videos)</span>
          </div>
        )}
      </Dropzone>

      {files.length > 0 && (
        <div className={styles.fileList}>
          {files.map(file => (
            <UploadFileItem
              key={file.id}
              file={file}
              onRemove={() => setFiles(prev => prev.filter(f => f.id !== file.id))}
            />
          ))}
        </div>
      )}

      {files.some(f => f.status === 'pending') && (
        <button
          className={styles.uploadButton}
          onClick={handleUpload}
          disabled={uploading}
        >
          {uploading ? 'Uploading...' : `Upload ${files.filter(f => f.status === 'pending').length} files`}
        </button>
      )}
    </div>
  );
};
```

### 10.8 CSS Grid Layout

```css
/* web/src/styles/MediaGrid.module.css */

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 8px;
  padding: 16px;
}

@media (max-width: 768px) {
  .grid {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 4px;
    padding: 8px;
  }
}

.card {
  position: relative;
  aspect-ratio: 1;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.card:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.card.selected {
  outline: 3px solid var(--primary-color);
  outline-offset: -3px;
}

.thumbnail {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.checkbox {
  position: absolute;
  top: 8px;
  left: 8px;
  opacity: 0;
  transition: opacity 0.2s;
}

.checkbox.visible,
.card:hover .checkbox {
  opacity: 1;
}

.videoIndicator {
  position: absolute;
  bottom: 8px;
  left: 8px;
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 4px;
  color: white;
  font-size: 12px;
}

.tags {
  position: absolute;
  bottom: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  justify-content: flex-end;
  max-width: 80%;
}

.tag {
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 10px;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 80px;
}
```

---

## 11. Mobile Specification

### 11.1 Navigation Integration

```
TaskManager Mobile (existing)
├── Tasks Tab (existing)
├── Media Tab (NEW) ◀─────────────
│   └── MediaGalleryScreen
│       ├── MediaViewerScreen
│       ├── AlbumsScreen
│       │   └── AlbumDetailScreen
│       ├── TagsScreen
│       └── MediaSettingsScreen
├── Notifications Tab (existing)
└── Profile Tab (existing)
```

### 11.2 New Screens

| Screen | Description |
|--------|-------------|
| MediaGalleryScreen | Main photo grid with search/filter |
| MediaViewerScreen | Full-screen image/video viewer |
| AlbumsScreen | Album list |
| AlbumDetailScreen | Album contents |
| TagsScreen | Tag management |
| MediaSettingsScreen | Storage & subscription |
| MediaUploadScreen | Upload with camera/gallery |

### 11.3 MediaGalleryScreen

```tsx
// mobile/src/screens/media/MediaGalleryScreen.tsx

import { FlatList, View, StyleSheet } from 'react-native';
import { useInfiniteQuery } from 'react-query';

export const MediaGalleryScreen: React.FC = () => {
  const [filters, setFilters] = useState<MediaFilters>({
    page: 1,
    limit: 50,
    sortBy: 'created',
    sortOrder: 'desc'
  });

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery(
    ['media', filters],
    ({ pageParam = 1 }) => mediaApi.getItems({ ...filters, page: pageParam }),
    {
      getNextPageParam: (lastPage) =>
        lastPage.pagination.page < lastPage.pagination.total_pages
          ? lastPage.pagination.page + 1
          : undefined
    }
  );

  const items = data?.pages.flatMap(p => p.items) ?? [];
  const numColumns = useWindowDimensions().width > 600 ? 4 : 3;

  return (
    <View style={styles.container}>
      <MediaHeader
        filters={filters}
        onFiltersChange={setFilters}
      />

      <FlatList
        data={items}
        numColumns={numColumns}
        keyExtractor={(item) => item.uuid}
        renderItem={({ item }) => (
          <MediaThumbnail
            item={item}
            size={THUMBNAIL_SIZE}
            onPress={() => navigation.navigate('MediaViewer', { uuid: item.uuid })}
          />
        )}
        onEndReached={() => hasNextPage && fetchNextPage()}
        onEndReachedThreshold={0.5}
        ListFooterComponent={isFetchingNextPage ? <ActivityIndicator /> : null}
      />

      <UploadFAB onPress={() => navigation.navigate('MediaUpload')} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  }
});
```

### 11.4 Upload Screen with Camera

```tsx
// mobile/src/screens/media/MediaUploadScreen.tsx

import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';

export const MediaUploadScreen: React.FC = () => {
  const [uploads, setUploads] = useState<UploadItem[]>([]);

  const pickFromGallery = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.All,
      allowsMultipleSelection: true,
      quality: 1,
    });

    if (!result.canceled) {
      addFilesToUpload(result.assets);
    }
  };

  const takePhoto = async () => {
    const permission = await ImagePicker.requestCameraPermissionsAsync();
    if (!permission.granted) {
      Alert.alert('Permission required', 'Camera access is needed to take photos');
      return;
    }

    const result = await ImagePicker.launchCameraAsync({
      quality: 1,
    });

    if (!result.canceled) {
      addFilesToUpload(result.assets);
    }
  };

  const uploadFile = async (item: UploadItem) => {
    const formData = new FormData();
    formData.append('file', {
      uri: item.uri,
      type: item.mimeType,
      name: item.filename
    } as any);

    try {
      await mediaApi.upload(formData, (progress) => {
        updateUploadProgress(item.id, progress);
      });
      markUploadComplete(item.id);
    } catch (error) {
      markUploadError(item.id, error.message);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.options}>
        <TouchableOpacity style={styles.option} onPress={takePhoto}>
          <CameraIcon />
          <Text>Take Photo</Text>
        </TouchableOpacity>

        <TouchableOpacity style={styles.option} onPress={pickFromGallery}>
          <GalleryIcon />
          <Text>Choose from Gallery</Text>
        </TouchableOpacity>
      </View>

      {uploads.length > 0 && (
        <FlatList
          data={uploads}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <UploadListItem
              item={item}
              onRemove={() => removeUpload(item.id)}
            />
          )}
        />
      )}

      {uploads.some(u => u.status === 'pending') && (
        <Button
          title="Upload All"
          onPress={() => uploads.filter(u => u.status === 'pending').forEach(uploadFile)}
        />
      )}
    </View>
  );
};
```

### 11.5 Offline Support

```typescript
// mobile/src/services/mediaOfflineService.ts

import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';

class MediaOfflineService {
  private pendingUploads: PendingUpload[] = [];

  async init() {
    // Load pending uploads from storage
    const stored = await AsyncStorage.getItem('media_pending_uploads');
    if (stored) {
      this.pendingUploads = JSON.parse(stored);
    }

    // Listen for network changes
    NetInfo.addEventListener(state => {
      if (state.isConnected && this.pendingUploads.length > 0) {
        this.processPendingUploads();
      }
    });
  }

  async queueUpload(file: MediaFile) {
    this.pendingUploads.push({
      id: crypto.randomUUID(),
      file,
      createdAt: new Date().toISOString(),
      status: 'pending'
    });
    await this.savePendingUploads();
  }

  private async processPendingUploads() {
    for (const upload of this.pendingUploads.filter(u => u.status === 'pending')) {
      try {
        upload.status = 'uploading';
        await mediaApi.upload(upload.file);
        upload.status = 'complete';
      } catch (error) {
        upload.status = 'error';
        upload.error = error.message;
      }
    }

    // Remove completed uploads
    this.pendingUploads = this.pendingUploads.filter(u => u.status !== 'complete');
    await this.savePendingUploads();
  }

  private async savePendingUploads() {
    await AsyncStorage.setItem('media_pending_uploads', JSON.stringify(this.pendingUploads));
  }
}

export const mediaOfflineService = new MediaOfflineService();
```

---

## 12. Billing Integration

### 12.1 Separate Product Billing

Media Library uses the **same subscription_plans table** but has its own subscription records in `media_subscriptions`.

```typescript
// Plan IDs (shared with TaskManager)
// id: 1 = free (250MB, 7 days)
// id: 2 = paid ($20/yr, 5GB, 30 days)
// id: 3 = premium ($99/yr, 100GB, unlimited)

// Example: User billing status
interface UserBillingStatus {
  taskManager: {
    plan: 'paid',
    storage_used: 1500000000,  // 1.5 GB
    storage_limit: 5368709120  // 5 GB
  },
  mediaLibrary: {
    plan: 'premium',
    storage_used: 45000000000,  // 45 GB
    storage_limit: 107374182400 // 100 GB
  },
  totalAnnualCost: 119  // $20 + $99
}
```

### 12.2 Stripe Integration

```typescript
// src/services/mediaBillingService.ts

export class MediaBillingService {
  // Stripe product/price IDs (separate from TaskManager)
  private readonly STRIPE_PRODUCTS = {
    paid: {
      productId: 'prod_media_paid',
      priceId: 'price_media_paid_yearly'  // $20/year
    },
    premium: {
      productId: 'prod_media_premium',
      priceId: 'price_media_premium_yearly'  // $99/year
    }
  };

  async createCheckoutSession(
    userId: number,
    plan: 'paid' | 'premium',
    successUrl: string,
    cancelUrl: string
  ): Promise<string> {
    const user = await this.getUser(userId);

    const session = await stripe.checkout.sessions.create({
      mode: 'subscription',
      customer_email: user.email,
      line_items: [{
        price: this.STRIPE_PRODUCTS[plan].priceId,
        quantity: 1
      }],
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        user_id: userId.toString(),
        product: 'media_library'
      }
    });

    return session.url!;
  }

  async handleWebhook(event: Stripe.Event) {
    switch (event.type) {
      case 'checkout.session.completed':
        await this.handleCheckoutComplete(event.data.object);
        break;
      case 'customer.subscription.updated':
        await this.handleSubscriptionUpdate(event.data.object);
        break;
      case 'customer.subscription.deleted':
        await this.handleSubscriptionCanceled(event.data.object);
        break;
    }
  }

  async canUploadFile(userId: number, fileSize: number): Promise<UploadCheck> {
    const storage = await this.getStorageStatus(userId);
    const newTotal = storage.used_bytes + fileSize;

    if (newTotal > storage.limit_bytes) {
      return {
        allowed: false,
        reason: 'storage_exceeded',
        current_usage: storage.used_bytes,
        limit: storage.limit_bytes,
        file_size: fileSize
      };
    }

    return { allowed: true };
  }

  async trackFileUpload(userId: number, fileSize: number): Promise<void> {
    await pool.query(`
      INSERT INTO media_user_storage (user_id, total_bytes, file_count)
      VALUES ($1, $2, 1)
      ON CONFLICT (user_id) DO UPDATE SET
        total_bytes = media_user_storage.total_bytes + $2,
        file_count = media_user_storage.file_count + 1,
        updated_at = NOW()
    `, [userId, fileSize]);
  }

  async trackFileDelete(userId: number, fileSize: number): Promise<void> {
    await pool.query(`
      UPDATE media_user_storage SET
        total_bytes = GREATEST(0, total_bytes - $2),
        file_count = GREATEST(0, file_count - 1),
        updated_at = NOW()
      WHERE user_id = $1
    `, [userId, fileSize]);
  }
}
```

### 12.3 IAP Integration

```typescript
// src/controllers/mediaIapController.ts

export class MediaIapController {
  // Apple IAP product IDs
  private readonly APPLE_PRODUCTS = {
    paid: 'com.taskmanager.media.paid.yearly',
    premium: 'com.taskmanager.media.premium.yearly'
  };

  // Google Play product IDs
  private readonly GOOGLE_PRODUCTS = {
    paid: 'media_paid_yearly',
    premium: 'media_premium_yearly'
  };

  async verifyApplePurchase(userId: number, receiptData: string): Promise<IapResult> {
    // Verify with Apple's servers
    const verification = await this.appleService.verifyReceipt(receiptData);

    if (!verification.valid) {
      return { success: false, error: 'Invalid receipt' };
    }

    // Find matching product
    const purchase = verification.latestReceipt;
    const plan = this.getPlanFromAppleProduct(purchase.productId);

    // Create/update subscription
    await this.createMediaSubscription(userId, plan, 'apple', purchase);

    return { success: true, plan };
  }

  async verifyGooglePurchase(
    userId: number,
    purchaseToken: string,
    productId: string
  ): Promise<IapResult> {
    // Verify with Google Play
    const verification = await this.googleService.verifyPurchase(purchaseToken, productId);

    if (!verification.valid) {
      return { success: false, error: 'Invalid purchase' };
    }

    const plan = this.getPlanFromGoogleProduct(productId);

    // Create/update subscription
    await this.createMediaSubscription(userId, plan, 'google', verification);

    return { success: true, plan };
  }
}
```

### 12.4 File Retention Service

```typescript
// src/services/mediaRetentionService.ts

import cron from 'node-cron';

export class MediaRetentionService {
  init() {
    // Run daily at 3 AM
    cron.schedule('0 3 * * *', () => this.cleanupExpiredFiles());
  }

  async cleanupExpiredFiles(): Promise<CleanupResult> {
    const result = { deleted: 0, freedBytes: 0 };

    // Get files to delete based on retention policy
    const expiredFiles = await pool.query(`
      SELECT mi.id, mi.uuid, mi.user_id, mi.storage_key, mi.thumbnail_key,
             mi.original_key, mi.processed_size_bytes
      FROM media_items mi
      JOIN media_user_storage mus ON mi.user_id = mus.user_id
      LEFT JOIN media_subscriptions ms ON mi.user_id = ms.user_id AND ms.status = 'active'
      LEFT JOIN subscription_plans sp ON ms.plan_id = sp.id
      WHERE mi.deleted_at IS NULL
        AND mi.created_at < NOW() - INTERVAL '1 day' * COALESCE(sp.retention_days, 7)
        AND COALESCE(sp.retention_days, 7) < 9999  -- Skip unlimited retention
    `);

    for (const file of expiredFiles.rows) {
      try {
        // Delete from DO Spaces
        await storageService.deleteFiles([
          file.storage_key,
          file.thumbnail_key,
          file.original_key
        ].filter(Boolean));

        // Mark as deleted in database
        await pool.query(`
          UPDATE media_items SET deleted_at = NOW() WHERE id = $1
        `, [file.id]);

        // Update storage tracking
        await mediaBillingService.trackFileDelete(file.user_id, file.processed_size_bytes);

        result.deleted++;
        result.freedBytes += file.processed_size_bytes;
      } catch (error) {
        console.error(`Failed to delete file ${file.uuid}:`, error);
      }
    }

    console.log(`Retention cleanup: deleted ${result.deleted} files, freed ${formatBytes(result.freedBytes)}`);
    return result;
  }
}
```

---

## 13. Security

### 13.1 Access Control

```typescript
// All media endpoints require authentication
router.use(authenticateToken);

// Users can only access their own media
async function verifyMediaOwnership(req: Request, res: Response, next: NextFunction) {
  const { uuid } = req.params;
  const userId = req.user!.userId;

  const result = await pool.query(
    'SELECT id FROM media_items WHERE uuid = $1 AND user_id = $2 AND deleted_at IS NULL',
    [uuid, userId]
  );

  if (result.rows.length === 0) {
    return res.status(404).json({ success: false, error: 'Media not found' });
  }

  req.mediaId = result.rows[0].id;
  next();
}

// Apply to specific routes
router.get('/items/:uuid', verifyMediaOwnership, getMediaItem);
router.patch('/items/:uuid', verifyMediaOwnership, updateMediaItem);
router.delete('/items/:uuid', verifyMediaOwnership, deleteMediaItem);
```

### 13.2 File Validation

```typescript
// src/middleware/mediaUpload.ts

const ALLOWED_IMAGE_TYPES = [
  'image/jpeg',
  'image/png',
  'image/gif',
  'image/heic',
  'image/heif',
  'image/webp'
];

const ALLOWED_VIDEO_TYPES = [
  'video/mp4',
  'video/quicktime',
  'video/x-m4v'
];

const MAX_IMAGE_SIZE = 100 * 1024 * 1024;  // 100 MB
const MAX_VIDEO_SIZE = 500 * 1024 * 1024;  // 500 MB

function validateFile(file: Express.Multer.File): ValidationResult {
  // Check MIME type
  const isImage = ALLOWED_IMAGE_TYPES.includes(file.mimetype);
  const isVideo = ALLOWED_VIDEO_TYPES.includes(file.mimetype);

  if (!isImage && !isVideo) {
    return { valid: false, error: 'Invalid file type' };
  }

  // Check file size
  const maxSize = isImage ? MAX_IMAGE_SIZE : MAX_VIDEO_SIZE;
  if (file.size > maxSize) {
    return {
      valid: false,
      error: `File too large. Max ${formatBytes(maxSize)}`
    };
  }

  // Validate file magic bytes (prevent spoofing)
  const magicBytes = file.buffer.slice(0, 12);
  if (!validateMagicBytes(magicBytes, file.mimetype)) {
    return { valid: false, error: 'File content does not match declared type' };
  }

  return { valid: true, type: isImage ? 'image' : 'video' };
}
```

### 13.3 Signed URLs

```typescript
// All media access through signed URLs (except thumbnails via CDN)

async function getSignedUrl(key: string, expiresIn: number = 7 * 24 * 60 * 60): Promise<string> {
  const command = new GetObjectCommand({
    Bucket: DO_SPACES_BUCKET,
    Key: key
  });

  return getSignedUrl(s3Client, command, { expiresIn });
}

// Response includes signed URL
{
  "thumbnail_url": "https://cdn.../thumb.jpg",  // Public via CDN
  "url": "https://bucket.nyc3.digitaloceanspaces.com/..?X-Amz-Signature=..."  // Signed
}
```

### 13.4 Rate Limiting

```typescript
// src/middleware/mediaRateLimit.ts

import rateLimit from 'express-rate-limit';

// Upload rate limit: 100 uploads per hour
export const uploadRateLimit = rateLimit({
  windowMs: 60 * 60 * 1000,
  max: 100,
  message: { success: false, error: 'Upload limit exceeded. Try again later.' },
  keyGenerator: (req) => req.user!.userId.toString()
});

// General API rate limit: 1000 requests per minute
export const apiRateLimit = rateLimit({
  windowMs: 60 * 1000,
  max: 1000,
  message: { success: false, error: 'Rate limit exceeded' },
  keyGenerator: (req) => req.user!.userId.toString()
});

// Apply to routes
router.post('/upload', uploadRateLimit, uploadMedia);
router.use(apiRateLimit);
```

### 13.5 Privacy by Design

Privacy is a core principle of the Media Library. User data belongs to users.

#### 13.5.1 Data Minimization

```typescript
// We only collect what's necessary
interface MediaMetadataStored {
  // STORED - Required for functionality
  file_type: string;        // To render correctly
  dimensions: { w, h };     // For layout
  file_size: number;        // For storage tracking
  created_at: Date;         // For sorting

  // STORED - User-provided (optional)
  title?: string;
  description?: string;
  tags?: Tag[];

  // STRIPPED - Never stored
  // - GPS coordinates (stripped from EXIF)
  // - Camera serial numbers
  // - Device identifiers
  // - Thumbnail previews with location
}

// EXIF stripping during processing
async function processImage(buffer: Buffer): Promise<Buffer> {
  return sharp(buffer)
    .rotate()  // Apply rotation before stripping
    .withMetadata({
      // Only preserve orientation, strip everything else
      orientation: undefined  // Already applied via rotate()
    })
    .jpeg({ quality: 85 })
    .toBuffer();
}
```

#### 13.5.2 No Third-Party Access

| What | Policy |
|------|--------|
| **Analytics on media content** | None. We don't analyze photos/videos. |
| **AI/ML processing** | None. No facial recognition, object detection, or content analysis. |
| **Third-party SDKs** | None with media access. |
| **Advertising** | None. No ad networks see your data. |
| **Data sharing** | Never. Your data is never sold or shared. |
| **CDN access** | Thumbnails via DO CDN only. No third-party CDNs. |

#### 13.5.3 Encryption

```typescript
// Encryption at rest
// DigitalOcean Spaces provides server-side encryption (AES-256)

// All DO Spaces buckets use SSE by default
const uploadParams = {
  Bucket: DO_SPACES_BUCKET,
  Key: storageKey,
  Body: buffer,
  ContentType: mimeType,
  // SSE is automatic, but we can specify:
  ServerSideEncryption: 'AES256'
};

// Encryption in transit
// All connections use TLS 1.2+
// - Client ↔ API: HTTPS enforced
// - API ↔ DO Spaces: HTTPS enforced
// - API ↔ PostgreSQL: SSL required
```

#### 13.5.4 Data Isolation

```typescript
// Strict user isolation - no cross-user data access possible

// Storage key includes user_id (can't access other users' paths)
function generateStorageKey(userId: number, filename: string): string {
  const uuid = crypto.randomUUID();
  const year = new Date().getFullYear();
  const month = String(new Date().getMonth() + 1).padStart(2, '0');

  // User ID is part of the path - S3 policies enforce isolation
  return `users/${userId}/processed/${year}/${month}/${uuid}.jpg`;
}

// Database queries always filter by user_id
const getMedia = async (userId: number, uuid: string) => {
  // user_id is ALWAYS in the WHERE clause
  return pool.query(
    'SELECT * FROM media_items WHERE uuid = $1 AND user_id = $2',
    [uuid, userId]
  );
};

// S3 bucket policy (additional layer)
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:*",
      "Resource": "arn:aws:s3:::taskmanager-media/users/*/",
      "Condition": {
        "StringNotEquals": {
          "s3:prefix": "${aws:userid}/"
        }
      }
    }
  ]
}
```

#### 13.5.5 User Rights (GDPR/CCPA Compliant)

```typescript
// Right to Access - Export all user data
async function exportUserData(userId: number): Promise<DataExport> {
  const [media, tags, albums, subscription] = await Promise.all([
    pool.query('SELECT * FROM media_items WHERE user_id = $1', [userId]),
    pool.query('SELECT * FROM media_tags WHERE user_id = $1', [userId]),
    pool.query('SELECT * FROM media_albums WHERE user_id = $1', [userId]),
    pool.query('SELECT * FROM media_subscriptions WHERE user_id = $1', [userId])
  ]);

  // Generate download links for all media files
  const mediaWithUrls = await Promise.all(
    media.rows.map(async (item) => ({
      ...item,
      download_url: await getSignedUrl(item.storage_key, 7 * 24 * 60 * 60)
    }))
  );

  return {
    exported_at: new Date().toISOString(),
    media_items: mediaWithUrls,
    tags: tags.rows,
    albums: albums.rows,
    subscription: subscription.rows[0] || null
  };
}

// Right to Deletion - Complete data removal
async function deleteAllUserMediaData(userId: number): Promise<DeletionResult> {
  // 1. Get all storage keys
  const mediaFiles = await pool.query(
    'SELECT storage_key, thumbnail_key, original_key FROM media_items WHERE user_id = $1',
    [userId]
  );

  // 2. Delete from DO Spaces
  const keysToDelete = mediaFiles.rows.flatMap(f =>
    [f.storage_key, f.thumbnail_key, f.original_key].filter(Boolean)
  );
  await storageService.deleteFiles(keysToDelete);

  // 3. Delete from database (cascades handle related records)
  await pool.query('DELETE FROM media_items WHERE user_id = $1', [userId]);
  await pool.query('DELETE FROM media_tags WHERE user_id = $1', [userId]);
  await pool.query('DELETE FROM media_albums WHERE user_id = $1', [userId]);
  await pool.query('DELETE FROM media_user_storage WHERE user_id = $1', [userId]);
  await pool.query('DELETE FROM media_subscriptions WHERE user_id = $1', [userId]);

  return {
    files_deleted: keysToDelete.length,
    completed_at: new Date().toISOString()
  };
}

// Right to Portability - Standard format export
async function exportMediaPortable(userId: number): Promise<string> {
  // Create ZIP with:
  // - All original files (if Premium)
  // - All processed files
  // - metadata.json with tags, albums, dates
  // Returns signed URL to download ZIP
}
```

#### 13.5.6 What We Never Do

| Action | Status |
|--------|--------|
| Scan photos for advertising | Never |
| Train AI/ML models on user photos | Never |
| Share data with third parties | Never |
| Access photos without user action | Never |
| Store GPS/location from EXIF | Never (stripped) |
| Keep data after deletion request | Never (hard delete) |
| Use analytics on photo content | Never |
| Sell user data | Never |
| Allow employee access to photos | Prohibited (audit logged) |

#### 13.5.7 Transparency Logging

```typescript
// Log all access to user data (for audit purposes)
interface MediaAccessLog {
  timestamp: Date;
  user_id: number;
  action: 'view' | 'download' | 'delete' | 'export';
  media_id?: number;
  ip_address: string;
  user_agent: string;
}

// Users can view their access log
GET /api/media/access-log

// Response shows all access to their data
{
  "logs": [
    {
      "timestamp": "2025-11-21T10:30:00Z",
      "action": "view",
      "media_uuid": "abc123",
      "device": "iPhone (Safari)"
    }
  ]
}
```

#### 13.5.8 Privacy Policy Summary (User-Facing)

```markdown
## Your Photos, Your Data

**We store:**
- Your photos and videos (encrypted)
- Tags and albums you create
- Basic file info (size, type, dimensions)

**We never:**
- Scan your photos
- Use your photos for AI training
- Share your data with anyone
- Show you ads based on photo content
- Store your location (GPS stripped)

**You control:**
- Download all your data anytime
- Delete everything permanently
- See who accessed your data
- Export in standard formats
```

---

## 14. Performance

### 14.1 Database Indexes

Already defined in schema (Section 4):
- `idx_media_items_user_id` - User's media lookup
- `idx_media_items_uuid` - UUID lookup
- `idx_media_items_user_created` - Sorted listing
- `idx_media_items_search` - Full-text search (GIN)
- `idx_media_tags_user` - User's tags
- `idx_media_item_tags_*` - Tag associations

### 14.2 Query Optimization

```sql
-- Efficient gallery query with tags
EXPLAIN ANALYZE
SELECT
  mi.uuid, mi.file_type, mi.original_filename,
  mi.thumbnail_key, mi.created_at,
  (
    SELECT json_agg(json_build_object('id', mt.id, 'value', mt.tag_value, 'color', mt.color))
    FROM media_item_tags mit
    JOIN media_tags mt ON mit.tag_id = mt.id
    WHERE mit.media_item_id = mi.id
  ) as tags
FROM media_items mi
WHERE mi.user_id = 42
  AND mi.deleted_at IS NULL
ORDER BY mi.created_at DESC
LIMIT 50;

-- Expected: Index Scan using idx_media_items_user_created
```

### 14.3 Caching Strategy

```typescript
// Thumbnail URLs cached in CDN (DO Spaces CDN)
// Full image URLs are signed (no caching)

// Tag suggestions cached in memory (per user, 5 min TTL)
const tagSuggestionsCache = new NodeCache({ stdTTL: 300 });

async function getTagSuggestions(userId: number, prefix: string): Promise<Tag[]> {
  const cacheKey = `tags:${userId}:${prefix}`;

  let suggestions = tagSuggestionsCache.get<Tag[]>(cacheKey);
  if (!suggestions) {
    suggestions = await fetchTagSuggestions(userId, prefix);
    tagSuggestionsCache.set(cacheKey, suggestions);
  }

  return suggestions;
}
```

### 14.4 Image Loading Strategy

```typescript
// Frontend: Lazy loading with intersection observer
const MediaGrid = () => {
  return (
    <div className={styles.grid}>
      {items.map(item => (
        <LazyImage
          key={item.uuid}
          src={item.thumbnail_url}
          placeholder={PLACEHOLDER_BLUR}
          onVisible={() => prefetchFullImage(item.url)}
        />
      ))}
    </div>
  );
};

// Prefetch full image when thumbnail is visible
function prefetchFullImage(url: string) {
  const img = new Image();
  img.src = url;
}
```

---

## 15. Implementation Phases

### Phase 1: Core Infrastructure (Week 1-2)

**Backend:**
- [ ] Database migration (006_media_library.sql)
- [ ] DO Spaces service integration
- [ ] Image processing service (Sharp)
- [ ] Media controller (upload, list, get, delete)
- [ ] Storage tracking service
- [ ] Basic API endpoints

**Deliverables:**
- Upload images
- List user's images
- View single image
- Delete images
- Storage usage tracking

### Phase 2: Tagging System (Week 3)

**Backend:**
- [ ] Tag controller (CRUD)
- [ ] Tag association endpoints
- [ ] Tag suggestions endpoint
- [ ] Full-text search integration

**Deliverables:**
- Create/edit/delete tags
- Add/remove tags from media
- Tag autocomplete
- Basic search

### Phase 3: Web Frontend (Week 4-5)

**Frontend:**
- [ ] Media tab in navigation
- [ ] Gallery grid component
- [ ] Upload interface
- [ ] Media viewer (lightbox)
- [ ] Tag management UI
- [ ] Search/filter UI
- [ ] Storage indicator

**Deliverables:**
- Functional web interface
- Drag-drop upload
- Gallery with infinite scroll
- Full-screen viewer
- Tag filtering

### Phase 4: Albums (Week 6)

**Backend:**
- [ ] Album controller
- [ ] Album-media associations

**Frontend:**
- [ ] Albums page
- [ ] Album creation modal
- [ ] Album detail view
- [ ] Add to album from viewer

**Deliverables:**
- Create/edit/delete albums
- Add/remove items from albums
- Album cover selection

### Phase 5: Video Support (Week 7)

**Backend:**
- [ ] FFmpeg integration
- [ ] Video transcoding service
- [ ] Video thumbnail extraction

**Frontend:**
- [ ] Video player component
- [ ] Video upload handling
- [ ] Duration display

**Deliverables:**
- Upload and process videos
- Video playback
- Video thumbnails

### Phase 6: Billing Integration (Week 8)

**Backend:**
- [ ] Media subscription service
- [ ] Stripe checkout integration
- [ ] Webhook handlers
- [ ] File retention service

**Frontend:**
- [ ] Subscription status page
- [ ] Upgrade flow
- [ ] Storage warnings

**Deliverables:**
- Subscription management
- Payment processing
- Automatic file cleanup

### Phase 7: Mobile (Week 9-10)

**Mobile:**
- [ ] Media tab in navigation
- [ ] Gallery screen
- [ ] Upload screen (camera + gallery)
- [ ] Viewer screen
- [ ] Albums screen
- [ ] Offline upload queue
- [ ] IAP integration

**Deliverables:**
- Feature-complete mobile app
- Camera integration
- Background uploads

### Phase 8: Polish & Testing (Week 11-12)

- [ ] Performance optimization
- [ ] Error handling improvements
- [ ] Edge case testing
- [ ] Load testing
- [ ] Security audit
- [ ] Documentation

---

## 16. File Structure

### 16.1 Backend Additions

```
backend/src/
├── controllers/
│   ├── mediaController.ts          # Media CRUD operations
│   ├── mediaTagController.ts       # Tag management
│   ├── mediaAlbumController.ts     # Album management
│   └── mediaBillingController.ts   # Subscription management
│
├── routes/
│   └── mediaRoutes.ts              # All media API routes
│
├── services/
│   ├── storageService.ts           # DO Spaces operations
│   ├── thumbnailService.ts         # Image/video thumbnail generation
│   ├── mediaSearchService.ts       # Full-text search
│   ├── mediaBillingService.ts      # Storage tracking & subscriptions
│   └── mediaRetentionService.ts    # File cleanup cron
│
├── middleware/
│   ├── mediaUpload.ts              # Multer config for media
│   ├── mediaAuth.ts                # Media ownership verification
│   └── mediaRateLimit.ts           # Rate limiting
│
├── utils/
│   ├── mediaProcessor.ts           # Sharp image processing
│   └── videoProcessor.ts           # FFmpeg video processing
│
├── database/
│   └── migrations/
│       └── 006_media_library.sql   # Schema migration
│
└── types/
    └── media.ts                    # Media-related TypeScript types
```

### 16.2 Web Frontend Additions

```
web/src/
├── pages/
│   └── media/
│       ├── MediaLibraryPage.tsx
│       ├── MediaLibraryPage.module.css
│       ├── MediaViewerPage.tsx
│       ├── AlbumsPage.tsx
│       ├── AlbumDetailPage.tsx
│       ├── TagsPage.tsx
│       └── MediaSettingsPage.tsx
│
├── components/
│   └── media/
│       ├── MediaGrid.tsx
│       ├── MediaGrid.module.css
│       ├── MediaCard.tsx
│       ├── MediaViewer.tsx
│       ├── MediaUploader.tsx
│       ├── TagSelector.tsx
│       ├── TagChip.tsx
│       ├── AlbumCard.tsx
│       ├── SearchBar.tsx
│       ├── FilterDropdown.tsx
│       └── StorageIndicator.tsx
│
├── services/
│   └── mediaApi.ts                 # Media API client
│
├── hooks/
│   ├── useMediaLibrary.ts
│   ├── useMediaUpload.ts
│   └── useMediaTags.ts
│
└── types/
    └── media.ts
```

### 16.3 Mobile Additions

```
mobile/src/
├── screens/
│   └── media/
│       ├── MediaGalleryScreen.tsx
│       ├── MediaViewerScreen.tsx
│       ├── MediaUploadScreen.tsx
│       ├── AlbumsScreen.tsx
│       ├── AlbumDetailScreen.tsx
│       ├── TagsScreen.tsx
│       └── MediaSettingsScreen.tsx
│
├── components/
│   └── media/
│       ├── MediaThumbnail.tsx
│       ├── MediaGrid.tsx
│       ├── TagBadge.tsx
│       ├── AlbumCover.tsx
│       └── UploadProgress.tsx
│
├── services/
│   ├── mediaApi.ts
│   └── mediaOfflineService.ts
│
└── types/
    └── media.ts
```

---

## Appendix A: Environment Variables

```bash
# Add to .env

# DigitalOcean Spaces
DO_SPACES_ENDPOINT=nyc3.digitaloceanspaces.com
DO_SPACES_REGION=nyc3
DO_SPACES_BUCKET=taskmanager-media
DO_SPACES_ACCESS_KEY=your_access_key
DO_SPACES_SECRET_KEY=your_secret_key
DO_SPACES_CDN_ENDPOINT=taskmanager-media.nyc3.cdn.digitaloceanspaces.com

# Media Library Stripe (separate from TaskManager)
STRIPE_MEDIA_PAID_PRICE_ID=price_media_paid_yearly
STRIPE_MEDIA_PREMIUM_PRICE_ID=price_media_premium_yearly
STRIPE_MEDIA_WEBHOOK_SECRET=whsec_media_...

# Media Library Feature Flag
MEDIA_LIBRARY_ENABLED=true
```

---

## Appendix B: API Response Formats

### Success Response
```json
{
  "success": true,
  "data": { ... }
}
```

### Error Response
```json
{
  "success": false,
  "error": "Human-readable error message",
  "code": "ERROR_CODE",
  "details": { ... }
}
```

### Pagination
```json
{
  "success": true,
  "data": {
    "items": [...],
    "pagination": {
      "page": 1,
      "limit": 50,
      "total_items": 342,
      "total_pages": 7
    }
  }
}
```

---

## Appendix C: Error Codes

| Code | HTTP Status | Description |
|------|-------------|-------------|
| `INVALID_FILE_TYPE` | 400 | Unsupported file format |
| `FILE_TOO_LARGE` | 413 | File exceeds size limit |
| `STORAGE_EXCEEDED` | 402 | Storage quota exceeded |
| `MEDIA_NOT_FOUND` | 404 | Media item doesn't exist |
| `TAG_NOT_FOUND` | 404 | Tag doesn't exist |
| `ALBUM_NOT_FOUND` | 404 | Album doesn't exist |
| `DUPLICATE_TAG` | 409 | Tag already exists |
| `UPLOAD_FAILED` | 500 | Storage upload failed |
| `PROCESSING_FAILED` | 500 | Media processing failed |

---

---

## Appendix D: End-to-End Encryption (Future Implementation)

This appendix documents the full E2E encryption architecture for future implementation. With E2E, the server never has access to unencrypted media - only the user holds the decryption keys.

### D.1 E2E Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              CLIENT DEVICE                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │
│  │  Photo   │───▶│  Generate    │───▶│   Encrypt    │───▶│   Upload     │  │
│  │  Select  │    │  Thumbnail   │    │   (AES-GCM)  │    │  Encrypted   │  │
│  └──────────┘    │  (Client)    │    │              │    │    Blob      │  │
│                  └──────────────┘    └──────────────┘    └──────┬───────┘  │
│                                                                  │          │
│  ┌─────────────────────────────────────────────────────────────┐ │          │
│  │                    KEY MANAGEMENT                            │ │          │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │ │          │
│  │  │  Password   │─▶│   PBKDF2    │─▶│  Master Key (MEK)   │  │ │          │
│  │  │             │  │  100k iter  │  │  AES-256-GCM        │  │ │          │
│  │  └─────────────┘  └─────────────┘  └──────────┬──────────┘  │ │          │
│  │                                               │              │ │          │
│  │                    ┌──────────────────────────┼──────────┐   │ │          │
│  │                    ▼                          ▼          ▼   │ │          │
│  │              ┌──────────┐              ┌──────────┐ ┌──────┐ │ │          │
│  │              │ File Key │              │ File Key │ │ ...  │ │ │          │
│  │              │   (FK1)  │              │   (FK2)  │ │      │ │ │          │
│  │              └──────────┘              └──────────┘ └──────┘ │ │          │
│  └─────────────────────────────────────────────────────────────┘ │          │
│                                                                  │          │
└──────────────────────────────────────────────────────────────────┼──────────┘
                                                                   │
                                                        [HTTPS/TLS]│
                                                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              SERVER (Zero Knowledge)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Server stores:                          Server CANNOT:                      │
│  ✓ Encrypted blobs                       ✗ Decrypt files                     │
│  ✓ Encrypted thumbnails                  ✗ View photos/videos                │
│  ✓ Encrypted metadata                    ✗ Read filenames                    │
│  ✓ Encrypted file keys (wrapped)         ✗ Access without user key           │
│  ✓ Salt for key derivation               ✗ Recover lost passwords            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### D.2 Key Hierarchy

```
User Password
      │
      ▼ PBKDF2 (100,000 iterations, SHA-256)
      │
┌─────┴─────┐
│           │
▼           ▼
MEK         Auth Key
(Master     (For server
Encrypt     authentication,
Key)        NOT for encryption)
│
├─── Encrypts ──▶ File Key 1 ──▶ Encrypts File 1
├─── Encrypts ──▶ File Key 2 ──▶ Encrypts File 2
├─── Encrypts ──▶ File Key 3 ──▶ Encrypts File 3
└─── Encrypts ──▶ Tag Keys   ──▶ Encrypts tag values
```

### D.3 Database Schema Changes for E2E

```sql
-- Additional columns for E2E support
ALTER TABLE users ADD COLUMN e2e_enabled BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN e2e_salt BYTEA;  -- Salt for PBKDF2
ALTER TABLE users ADD COLUMN e2e_key_check BYTEA;  -- Encrypted known value for key verification
ALTER TABLE users ADD COLUMN e2e_recovery_key_hash VARCHAR(64);  -- Hash of recovery key

-- Media items with E2E
ALTER TABLE media_items ADD COLUMN encrypted BOOLEAN DEFAULT FALSE;
ALTER TABLE media_items ADD COLUMN encryption_version VARCHAR(20);  -- 'v1-aes-256-gcm'
ALTER TABLE media_items ADD COLUMN encrypted_file_key BYTEA;  -- File key encrypted with MEK
ALTER TABLE media_items ADD COLUMN file_key_nonce BYTEA;  -- Nonce for file key encryption
ALTER TABLE media_items ADD COLUMN content_nonce BYTEA;  -- Nonce for content encryption

-- Encrypted tags (tag values encrypted, types remain plaintext for filtering)
ALTER TABLE media_tags ADD COLUMN encrypted BOOLEAN DEFAULT FALSE;
ALTER TABLE media_tags ADD COLUMN encrypted_value BYTEA;  -- Encrypted tag value
ALTER TABLE media_tags ADD COLUMN value_nonce BYTEA;

-- Recovery keys (for account recovery)
CREATE TABLE e2e_recovery_keys (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    key_hash VARCHAR(64) NOT NULL,  -- SHA-256 of recovery key
    encrypted_mek BYTEA NOT NULL,   -- MEK encrypted with recovery key
    mek_nonce BYTEA NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    used_at TIMESTAMP  -- NULL until used
);

-- Device keys (for multi-device support)
CREATE TABLE e2e_device_keys (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    device_id VARCHAR(64) NOT NULL,
    device_name VARCHAR(100),
    encrypted_mek BYTEA NOT NULL,  -- MEK encrypted with device key
    mek_nonce BYTEA NOT NULL,
    public_key BYTEA,  -- For device-to-device key sharing
    last_used TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, device_id)
);
```

### D.4 Client-Side Encryption Implementation

#### D.4.1 Key Derivation (Web/React)

```typescript
// src/lib/e2e/keyDerivation.ts

const PBKDF2_ITERATIONS = 100000;
const SALT_LENGTH = 32;
const KEY_LENGTH = 256;

interface DerivedKeys {
  masterKey: CryptoKey;      // For encrypting file keys
  authKey: Uint8Array;       // For server authentication (not encryption)
}

export async function deriveKeysFromPassword(
  password: string,
  salt: Uint8Array
): Promise<DerivedKeys> {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);

  // Import password as key material
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    passwordBuffer,
    'PBKDF2',
    false,
    ['deriveBits', 'deriveKey']
  );

  // Derive master encryption key
  const masterKey = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: PBKDF2_ITERATIONS,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: KEY_LENGTH },
    false,  // NOT extractable
    ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
  );

  // Derive separate auth key (different salt derivation)
  const authSalt = new Uint8Array(SALT_LENGTH);
  await crypto.subtle.digest('SHA-256', new Uint8Array([...salt, 0x01]))
    .then(hash => authSalt.set(new Uint8Array(hash).slice(0, SALT_LENGTH)));

  const authBits = await crypto.subtle.deriveBits(
    {
      name: 'PBKDF2',
      salt: authSalt,
      iterations: PBKDF2_ITERATIONS,
      hash: 'SHA-256'
    },
    keyMaterial,
    256
  );

  return {
    masterKey,
    authKey: new Uint8Array(authBits)
  };
}

export function generateSalt(): Uint8Array {
  return crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
}

export function generateNonce(): Uint8Array {
  return crypto.getRandomValues(new Uint8Array(12));  // 96 bits for AES-GCM
}
```

#### D.4.2 File Encryption

```typescript
// src/lib/e2e/fileEncryption.ts

interface EncryptedFile {
  encryptedContent: ArrayBuffer;
  contentNonce: Uint8Array;
  encryptedFileKey: ArrayBuffer;
  fileKeyNonce: Uint8Array;
  encryptedThumbnail: ArrayBuffer;
  thumbnailNonce: Uint8Array;
  encryptedMetadata: ArrayBuffer;
  metadataNonce: Uint8Array;
}

interface FileMetadata {
  originalFilename: string;
  mimeType: string;
  width?: number;
  height?: number;
  duration?: number;
  takenAt?: string;
}

export async function encryptFile(
  file: File,
  thumbnail: Blob,
  metadata: FileMetadata,
  masterKey: CryptoKey
): Promise<EncryptedFile> {
  // Generate unique file key for this file
  const fileKey = await crypto.subtle.generateKey(
    { name: 'AES-GCM', length: 256 },
    true,  // Extractable (to wrap with master key)
    ['encrypt', 'decrypt']
  );

  // Encrypt file content with file key
  const contentNonce = generateNonce();
  const fileBuffer = await file.arrayBuffer();
  const encryptedContent = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: contentNonce },
    fileKey,
    fileBuffer
  );

  // Encrypt thumbnail with same file key
  const thumbnailNonce = generateNonce();
  const thumbnailBuffer = await thumbnail.arrayBuffer();
  const encryptedThumbnail = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: thumbnailNonce },
    fileKey,
    thumbnailBuffer
  );

  // Encrypt metadata with file key
  const metadataNonce = generateNonce();
  const metadataBuffer = new TextEncoder().encode(JSON.stringify(metadata));
  const encryptedMetadata = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: metadataNonce },
    fileKey,
    metadataBuffer
  );

  // Wrap (encrypt) file key with master key
  const fileKeyNonce = generateNonce();
  const encryptedFileKey = await crypto.subtle.wrapKey(
    'raw',
    fileKey,
    masterKey,
    { name: 'AES-GCM', iv: fileKeyNonce }
  );

  return {
    encryptedContent,
    contentNonce,
    encryptedFileKey,
    fileKeyNonce,
    encryptedThumbnail,
    thumbnailNonce,
    encryptedMetadata,
    metadataNonce
  };
}

export async function decryptFile(
  encryptedData: EncryptedFile,
  masterKey: CryptoKey
): Promise<{ content: ArrayBuffer; thumbnail: ArrayBuffer; metadata: FileMetadata }> {
  // Unwrap file key using master key
  const fileKey = await crypto.subtle.unwrapKey(
    'raw',
    encryptedData.encryptedFileKey,
    masterKey,
    { name: 'AES-GCM', iv: encryptedData.fileKeyNonce },
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );

  // Decrypt content
  const content = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: encryptedData.contentNonce },
    fileKey,
    encryptedData.encryptedContent
  );

  // Decrypt thumbnail
  const thumbnail = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: encryptedData.thumbnailNonce },
    fileKey,
    encryptedData.encryptedThumbnail
  );

  // Decrypt metadata
  const metadataBuffer = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: encryptedData.metadataNonce },
    fileKey,
    encryptedData.encryptedMetadata
  );
  const metadata = JSON.parse(new TextDecoder().decode(metadataBuffer));

  return { content, thumbnail, metadata };
}
```

#### D.4.3 Client-Side Thumbnail Generation

```typescript
// src/lib/e2e/thumbnailGenerator.ts

const THUMBNAIL_SIZE = 300;
const THUMBNAIL_QUALITY = 0.8;

export async function generateThumbnail(file: File): Promise<Blob> {
  if (file.type.startsWith('image/')) {
    return generateImageThumbnail(file);
  } else if (file.type.startsWith('video/')) {
    return generateVideoThumbnail(file);
  }
  throw new Error('Unsupported file type for thumbnail');
}

async function generateImageThumbnail(file: File): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    img.onload = () => {
      // Calculate dimensions maintaining aspect ratio
      let width = img.width;
      let height = img.height;
      const ratio = Math.min(THUMBNAIL_SIZE / width, THUMBNAIL_SIZE / height);

      if (ratio < 1) {
        width *= ratio;
        height *= ratio;
      }

      canvas.width = width;
      canvas.height = height;

      // Draw and export
      ctx.drawImage(img, 0, 0, width, height);
      canvas.toBlob(
        (blob) => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
        'image/jpeg',
        THUMBNAIL_QUALITY
      );

      URL.revokeObjectURL(img.src);
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
}

async function generateVideoThumbnail(file: File): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    video.onloadedmetadata = () => {
      // Seek to 1 second or 25% of duration
      video.currentTime = Math.min(1, video.duration * 0.25);
    };

    video.onseeked = () => {
      // Calculate dimensions
      let width = video.videoWidth;
      let height = video.videoHeight;
      const ratio = Math.min(THUMBNAIL_SIZE / width, THUMBNAIL_SIZE / height);

      if (ratio < 1) {
        width *= ratio;
        height *= ratio;
      }

      canvas.width = width;
      canvas.height = height;

      ctx.drawImage(video, 0, 0, width, height);
      canvas.toBlob(
        (blob) => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
        'image/jpeg',
        THUMBNAIL_QUALITY
      );

      URL.revokeObjectURL(video.src);
    };

    video.onerror = () => reject(new Error('Failed to load video'));
    video.src = URL.createObjectURL(file);
  });
}
```

#### D.4.4 Client-Side Image Processing (Resize to 1080p)

```typescript
// src/lib/e2e/imageProcessor.ts

const MAX_DIMENSION = 1920;  // 1080p
const OUTPUT_QUALITY = 0.85;

export async function processImage(file: File): Promise<Blob> {
  // Handle HEIC conversion (requires heic2any library)
  if (file.type === 'image/heic' || file.type === 'image/heif') {
    const heic2any = await import('heic2any');
    const converted = await heic2any.default({
      blob: file,
      toType: 'image/jpeg',
      quality: OUTPUT_QUALITY
    });
    file = converted as Blob as File;
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    img.onload = () => {
      let width = img.width;
      let height = img.height;

      // Only resize if larger than max
      if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
        const ratio = Math.min(MAX_DIMENSION / width, MAX_DIMENSION / height);
        width *= ratio;
        height *= ratio;
      }

      canvas.width = width;
      canvas.height = height;

      // Handle EXIF orientation
      ctx.drawImage(img, 0, 0, width, height);

      canvas.toBlob(
        (blob) => blob ? resolve(blob) : reject(new Error('Failed to process image')),
        'image/jpeg',
        OUTPUT_QUALITY
      );

      URL.revokeObjectURL(img.src);
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
}

export async function getImageDimensions(file: File): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
      URL.revokeObjectURL(img.src);
    };
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
}
```

### D.5 Mobile Implementation (React Native)

#### D.5.1 React Native Crypto

```typescript
// mobile/src/lib/e2e/crypto.ts

import * as Crypto from 'expo-crypto';
import * as FileSystem from 'expo-file-system';

// React Native doesn't have Web Crypto API
// Use expo-crypto + custom AES implementation or native modules

// Option 1: Use react-native-quick-crypto (native, fast)
import QuickCrypto from 'react-native-quick-crypto';

export async function deriveKey(password: string, salt: Uint8Array): Promise<Uint8Array> {
  return new Promise((resolve, reject) => {
    QuickCrypto.pbkdf2(
      password,
      Buffer.from(salt),
      100000,
      32,
      'sha256',
      (err, derivedKey) => {
        if (err) reject(err);
        else resolve(new Uint8Array(derivedKey));
      }
    );
  });
}

export async function encryptData(
  data: Uint8Array,
  key: Uint8Array,
  nonce: Uint8Array
): Promise<Uint8Array> {
  const cipher = QuickCrypto.createCipheriv('aes-256-gcm', key, nonce);
  const encrypted = Buffer.concat([
    cipher.update(Buffer.from(data)),
    cipher.final()
  ]);
  const authTag = cipher.getAuthTag();

  // Return nonce + authTag + ciphertext
  return new Uint8Array([...nonce, ...authTag, ...encrypted]);
}

export async function decryptData(
  encryptedData: Uint8Array,
  key: Uint8Array
): Promise<Uint8Array> {
  const nonce = encryptedData.slice(0, 12);
  const authTag = encryptedData.slice(12, 28);
  const ciphertext = encryptedData.slice(28);

  const decipher = QuickCrypto.createDecipheriv('aes-256-gcm', key, nonce);
  decipher.setAuthTag(Buffer.from(authTag));

  return new Uint8Array(Buffer.concat([
    decipher.update(Buffer.from(ciphertext)),
    decipher.final()
  ]));
}
```

#### D.5.2 Secure Key Storage (Mobile)

```typescript
// mobile/src/lib/e2e/keyStorage.ts

import * as SecureStore from 'expo-secure-store';

const MEK_KEY = 'e2e_master_key';
const SALT_KEY = 'e2e_salt';

export async function storeMasterKey(key: Uint8Array): Promise<void> {
  // Store in secure enclave (iOS Keychain / Android Keystore)
  await SecureStore.setItemAsync(
    MEK_KEY,
    Buffer.from(key).toString('base64'),
    {
      keychainAccessible: SecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
      requireAuthentication: true  // Require biometrics
    }
  );
}

export async function getMasterKey(): Promise<Uint8Array | null> {
  const stored = await SecureStore.getItemAsync(MEK_KEY);
  if (!stored) return null;
  return new Uint8Array(Buffer.from(stored, 'base64'));
}

export async function clearKeys(): Promise<void> {
  await SecureStore.deleteItemAsync(MEK_KEY);
  await SecureStore.deleteItemAsync(SALT_KEY);
}
```

### D.6 Recovery System

#### D.6.1 Recovery Key Generation

```typescript
// src/lib/e2e/recovery.ts

const RECOVERY_KEY_WORDS = 24;  // BIP39-style mnemonic

export async function generateRecoveryKey(): Promise<{
  mnemonic: string;
  key: Uint8Array;
}> {
  // Generate 256 bits of entropy
  const entropy = crypto.getRandomValues(new Uint8Array(32));

  // Convert to mnemonic (using BIP39 wordlist)
  const bip39 = await import('bip39');
  const mnemonic = bip39.entropyToMnemonic(Buffer.from(entropy));

  // Derive key from mnemonic
  const seed = await bip39.mnemonicToSeed(mnemonic);
  const key = new Uint8Array(seed.slice(0, 32));

  return { mnemonic, key };
}

export async function encryptMEKWithRecoveryKey(
  mek: CryptoKey,
  recoveryKey: Uint8Array
): Promise<{ encrypted: ArrayBuffer; nonce: Uint8Array }> {
  // Import recovery key as CryptoKey
  const wrappingKey = await crypto.subtle.importKey(
    'raw',
    recoveryKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['wrapKey']
  );

  const nonce = generateNonce();
  const encrypted = await crypto.subtle.wrapKey(
    'raw',
    mek,
    wrappingKey,
    { name: 'AES-GCM', iv: nonce }
  );

  return { encrypted, nonce };
}

export async function recoverMEKFromRecoveryKey(
  encryptedMEK: ArrayBuffer,
  nonce: Uint8Array,
  recoveryMnemonic: string
): Promise<CryptoKey> {
  const bip39 = await import('bip39');
  const seed = await bip39.mnemonicToSeed(recoveryMnemonic);
  const recoveryKey = new Uint8Array(seed.slice(0, 32));

  const unwrappingKey = await crypto.subtle.importKey(
    'raw',
    recoveryKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['unwrapKey']
  );

  return crypto.subtle.unwrapKey(
    'raw',
    encryptedMEK,
    unwrappingKey,
    { name: 'AES-GCM', iv: nonce },
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
  );
}
```

#### D.6.2 Recovery UI Flow

```
┌─────────────────────────────────────────────────────────────┐
│                  E2E ENCRYPTION SETUP                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Create strong password                                   │
│     ┌─────────────────────────────────────┐                 │
│     │ ●●●●●●●●●●●●●●●●                    │                 │
│     └─────────────────────────────────────┘                 │
│     Strength: ████████░░ Strong                             │
│                                                              │
│  2. Save your Recovery Key                                   │
│     ┌─────────────────────────────────────┐                 │
│     │ abandon ability able about above    │                 │
│     │ absent absorb abstract absurd abuse │                 │
│     │ access accident account accuse      │                 │
│     │ achieve acid acoustic acquire       │                 │
│     │ across act action actor actress     │                 │
│     └─────────────────────────────────────┘                 │
│                                                              │
│     ⚠️  Write this down and store safely!                   │
│        If you lose your password AND recovery key,          │
│        your photos are PERMANENTLY LOST.                    │
│                                                              │
│     [ ] I have saved my recovery key                        │
│                                                              │
│                        [Enable E2E Encryption]               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### D.7 Server-Side Changes for E2E

```typescript
// backend/src/controllers/mediaController.ts

// Upload endpoint for E2E encrypted files
async function uploadEncrypted(req: Request, res: Response) {
  const userId = req.user!.userId;

  // Verify user has E2E enabled
  const user = await pool.query(
    'SELECT e2e_enabled FROM users WHERE id = $1',
    [userId]
  );

  if (!user.rows[0]?.e2e_enabled) {
    return res.status(400).json({
      success: false,
      error: 'E2E encryption not enabled for this account'
    });
  }

  // Server receives encrypted blobs - CANNOT read them
  const {
    encryptedContent,      // Encrypted file
    contentNonce,
    encryptedThumbnail,    // Encrypted thumbnail
    thumbnailNonce,
    encryptedFileKey,      // File key wrapped with MEK
    fileKeyNonce,
    encryptedMetadata,     // Encrypted filename, etc.
    metadataNonce,
    fileSize,              // Plaintext (not sensitive)
    fileType               // 'image' | 'video' (not sensitive)
  } = req.body;

  // Upload encrypted blobs to DO Spaces
  const uuid = crypto.randomUUID();
  const contentKey = `users/${userId}/e2e/${uuid}.enc`;
  const thumbKey = `users/${userId}/e2e/${uuid}_thumb.enc`;

  await Promise.all([
    storageService.uploadEncrypted(contentKey, encryptedContent),
    storageService.uploadEncrypted(thumbKey, encryptedThumbnail)
  ]);

  // Store metadata (all encrypted values stored as-is)
  await pool.query(`
    INSERT INTO media_items (
      user_id, uuid, file_type, processed_size_bytes,
      storage_key, thumbnail_key,
      encrypted, encryption_version,
      encrypted_file_key, file_key_nonce,
      content_nonce
    ) VALUES ($1, $2, $3, $4, $5, $6, TRUE, 'v1-aes-256-gcm', $7, $8, $9)
    RETURNING uuid
  `, [
    userId, uuid, fileType, fileSize,
    contentKey, thumbKey,
    encryptedFileKey, fileKeyNonce, contentNonce
  ]);

  // Store encrypted metadata separately
  await pool.query(`
    INSERT INTO media_item_metadata (
      media_item_uuid, encrypted_metadata, metadata_nonce
    ) VALUES ($1, $2, $3)
  `, [uuid, encryptedMetadata, metadataNonce]);

  res.status(201).json({
    success: true,
    data: { uuid }
  });
}

// Server CANNOT generate thumbnails for E2E files
// Server CANNOT search file contents
// Server CANNOT read filenames
// Server CAN only store and retrieve encrypted blobs
```

### D.8 E2E Tag Encryption

```typescript
// Tags are encrypted so server can't see who/what is in photos

interface EncryptedTag {
  type: string;              // Plaintext: 'name', 'location', etc.
  encryptedValue: string;    // Encrypted: actual tag value
  valueNonce: string;
  searchToken: string;       // Blind index for searching
}

// Blind index allows searching without revealing values
async function createSearchToken(
  value: string,
  searchKey: Uint8Array
): Promise<string> {
  const normalized = value.toLowerCase().trim();
  const hmac = await crypto.subtle.sign(
    'HMAC',
    await crypto.subtle.importKey(
      'raw', searchKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
    ),
    new TextEncoder().encode(normalized)
  );
  // Truncate to prevent rainbow tables
  return Buffer.from(hmac).toString('base64').slice(0, 16);
}

// Search works on blind indices
// Server sees: searchToken = "a8Kj2mNx..."
// Server doesn't know: tag value = "John Smith"
```

### D.9 Performance Considerations

| Operation | Without E2E | With E2E | Mitigation |
|-----------|-------------|----------|------------|
| Upload | Fast | +200-500ms | Web Workers for encryption |
| Thumbnail gen | Server | Client | Pre-generate on select |
| Image resize | Server | Client | WASM (squoosh) |
| Gallery load | Fast | +50ms decrypt per visible | Cache decrypted thumbs |
| Search | Server SQL | Blind indices | Acceptable |
| Memory usage | Low | Higher | Stream large files |

#### Performance Optimizations

```typescript
// Use Web Workers for encryption (don't block UI)
// src/workers/encryptionWorker.ts

self.onmessage = async (e) => {
  const { file, masterKey, operation } = e.data;

  if (operation === 'encrypt') {
    const result = await encryptFile(file, masterKey);
    self.postMessage({ success: true, result });
  }
};

// Usage in React
const worker = new Worker(new URL('./encryptionWorker.ts', import.meta.url));
worker.postMessage({ file, masterKey, operation: 'encrypt' });
worker.onmessage = (e) => {
  if (e.data.success) uploadEncrypted(e.data.result);
};
```

### D.10 Migration Path (Non-E2E to E2E)

```typescript
// Users can enable E2E for new uploads while keeping old files unencrypted

interface MigrationStatus {
  totalFiles: number;
  migratedFiles: number;
  status: 'not_started' | 'in_progress' | 'complete';
}

// Background migration (client-side)
async function migrateToE2E(masterKey: CryptoKey): Promise<void> {
  const unencryptedFiles = await api.get('/media/items?encrypted=false');

  for (const file of unencryptedFiles) {
    // Download unencrypted file
    const content = await fetch(file.url).then(r => r.arrayBuffer());
    const thumbnail = await fetch(file.thumbnail_url).then(r => r.arrayBuffer());

    // Encrypt locally
    const encrypted = await encryptFile(
      new Blob([content]),
      new Blob([thumbnail]),
      { originalFilename: file.filename, mimeType: file.mime_type },
      masterKey
    );

    // Upload encrypted version
    await api.post('/media/migrate-to-e2e', {
      uuid: file.uuid,
      ...encrypted
    });

    // Server deletes unencrypted version
  }
}
```

### D.11 Security Audit Checklist

```markdown
## E2E Implementation Security Checklist

### Key Management
- [ ] PBKDF2 uses minimum 100,000 iterations
- [ ] Salt is unique per user (32 bytes)
- [ ] Master key never leaves client unencrypted
- [ ] Master key not stored in localStorage (use IndexedDB + Secure Context)
- [ ] Recovery key uses BIP39 with 256 bits entropy
- [ ] Auth key is separate from encryption key

### Encryption
- [ ] AES-256-GCM used for all encryption
- [ ] Unique nonce (96 bits) per encryption operation
- [ ] File keys are unique per file
- [ ] Auth tags verified before decryption
- [ ] No key reuse across files

### Mobile
- [ ] Keys stored in Secure Enclave (iOS) / Keystore (Android)
- [ ] Biometric authentication for key access
- [ ] Keys cleared on logout
- [ ] No keys in app screenshots/recordings

### Server
- [ ] Server never receives unencrypted content
- [ ] Server never receives master key
- [ ] No server-side decryption capability
- [ ] Encrypted blobs stored as-is
- [ ] Audit logging for all access

### Recovery
- [ ] Recovery key can restore account
- [ ] Password change re-encrypts file keys
- [ ] Lost password + lost recovery = data loss (documented)
- [ ] Recovery key verification on setup
```

### D.12 User Warnings

```markdown
## IMPORTANT: E2E Encryption Warnings

### Before Enabling E2E

⚠️ **DATA LOSS RISK**
If you lose BOTH your password AND recovery key, your photos and videos
are PERMANENTLY LOST. We cannot recover them. This is by design - it's
what makes E2E encryption secure.

⚠️ **NO PASSWORD RESET**
Unlike regular accounts, we cannot reset your password. Your password
is the only way to decrypt your data.

⚠️ **PERFORMANCE IMPACT**
- Uploads take longer (encryption happens on your device)
- Gallery may load slightly slower
- More battery usage on mobile

⚠️ **FEATURE LIMITATIONS**
- No server-side search by content
- Sharing requires additional key exchange
- Some features may not be available

### Recommendations
1. Use a strong, unique password
2. Store recovery key in a safe place (not on this device)
3. Consider a password manager
4. Test recovery key before uploading important photos
```

---

**End of Specification**
